How to define new graphics
==========================

The new graphics are controlled by newgrf.cfg (newgrfw.cfg for Windows),
which is simply a list of .grf files to include.  Each .grf file can
then define graphics for one or more vehicles.

In this document, you can find out how to define new sprites and
control how they are displayed.

Table of Contents

1)  Introduction to Pseudo-Sprites
2)  Definition of pseudo-sprites
3)  Pseudo-sprite actions
4)  General information and hints and tips



1) Introduction to Pseudo-Sprites
---------------------------------

Pseudo-Sprites are special entries in the .nfo file that corresponds to
a .grf file when decoded by GRFCodec.  They are the entries that do not
have an actual picture in a PCX file, and they start with an asterisk,
instead of the PCX file name.

This is what a regular sprite looks like:
    7 SPRITES\newship.pcx 162 200 09 46 72 -6 -7

This is what a pseudo-sprite looks like:
  125 * 17	 02 02 01 02 04 00 00 01 00 02 00 06 00 07 00 08 00

In each line, the first number is the sprite number.  It must increase
in consecutive integer numbers, starting from 0 for the first entry.

For regular sprites, the next part of the line is the PCX file name,
and the dimensions and offsets of the sprite.

For pseudo-sprites, the entry after the asterisk is the total length
of the pseudo-sprite data, in bytes.  After it follows the actual data,
also in individual bytes.  Note that the length must be given in decimal
notation, but the data is given in hexadecimal notation.

Pseudo-sprites exist in TTD's .grf files too, but their format is
unknown.  In a .grf file used by TTDPatch, however, the format is
described in the next section.  For example, you will find that the
example pseudo-sprite above means to TTDPatch:
	- this is the definition of a cargo ID for ships
	- it defines cargo ID number 1
	- there are two different sets of sprites for ships that are in motion
	- there are four different sets for ships being loaded or unloaded
	- after which follow the numbers of the sprite sets


2)  Definition of pseudo-sprites
--------------------------------

Each pseudo-sprite that is read by TTDPatch has the following format:

<sprite-num> *   <length> <data>

	sprite-num	The consecutive number of the sprite (see above)
	length		Total size of the pseudo-sprite, including the
			action byte and all data bytes
	data		The first byte of this is the so-called "action"
			that decides how this particular sprite is to be
			interpreted, and what it does


The following actions can be specified:

      Action	What it does
	0	Change vehicle info (like TTD Alter)
	1	Define new sprite block
	2	Define new cargo ID: mapping of cargo type and load status to sprite
	3	Define vehicle to cargo ID mapping
	4	Define new vehicle names
	5	New graphics such as pre-signals and overhead wires
	6	Apply newgrf.cfg parameter to following sprite data
	7	Skip following sprites if condition is true
	8	Define the GRF ID, description and copyright info
	9	Skip following sprites even during initialization
	A	Replace arbitrary TTD sprites
	B	Show error or warning messages
	C	Do nothing (useful as comments)
	D	Set parameters
	E	Deactivate other .grf file
	F	Define new town name styles

The format of the data of each action is different depending on the action,
and is described below.

These descriptions of the parameters are organized in this manner:

	Size  Name  Description

The size can have the following values:
	B	This parameter is a single byte
	W	This parameter is a two-byte word, specified in little-endian
		byte order, that is, low-byte first, followed by the high-byte
	D	This parameter is a four-byte dword, again in little-endian
		byte order, with the least significant byte first and the
		most significant byte last.
	S	This parameter is variable-length, zero terminated text string
	V	This parameter has a variable length, which depends on one
		of the previous parameters; it will be described there.


Each sprite in the .grf file is such a pseudo-sprite, except for the
graphics sprites preceeded by actions 1, 5 or A.

The first (pseudo-)sprite has a special format.  It defines how many entries
the .grf file contains in total.  TTDPatch needs to know that, because it
needs to reserve memory for each sprite in the file.

This is the format of the first sprite:

	*   4  <num-entries>

	D num-entries	The total number of sprites and pseudo-sprite
			in this .grf file.  May be slightly larger than
			the actual number, but must not be smaller.

If you give a number that's too large, you're wasting memory that may
be needed for actual sprites, and if the number is too low, the last
few sprites will have to be skipped, which may confuse TTDPatch.


3)  Pseudo-sprite actions
-------------------------


Action 0:	Define feature properties.
~~~~~~~~~

May appear only after an action 8 in the .grf file.

In general, the format is
	<00> <feature> <num-props> <num-info> <id> (<property <new-info>)...

	B feature	0, 1, 2 or 3 for trains, road vehicles, ships or planes
			4 for defining new train station sets
	B num-props	how many properties to change per vehicle/station
	B num-info	how many vehicles/stations to change
	B id		ID of first vehicle/station to change, if num-info is
			greater than one, this one and the following 
			vehicles/stations will be changed
	B property	what property to change, depends on the feature
	V new-info	new bytes of info (variable size; depends on properties)



For vehicles (features 0, 1, 2 or 3):
-------------------------------------

	Properties common to all vehicle types
	number	size	property
	00	W	date of introduction
	02	B	how fast reliability decays without maint initially
	03	B	vehicle life in years
	04	B	model life in years
	06	B	climates available (bit mask)
	07	B	load amount (amount of cargo transferred per unit
			of time if using gradualloading)

All of the above only apply to new games, or when using Cht: ReloadEngines.

The date is specified as number of days since 1920.  It will have a random
number from 0 to 511 days added to it at the start of every new game, or after
using "Cht: ResetVehicles".  Note that TTD stops updating vehicle type data
after the game ends in 2050, so all dates of introduction should be no later
than in 2044, to ensure that all vehicle types can be introduced and reach
their maximum reliability.

The reliability decay speed is used when a new vehicle is bought, and
specifies how quickly the reliability decays after servicing.  The initial
TTD default for all vehicles is 20.  If a vehicle goes without servicing
for a long time, or if it gets very, very old, this number increases,
meaning faster decay and more breakdowns.  Larger numbers mean faster decay,
smaller number slower decay.  If set to 0, reliability never decreases
in normal operation.

Vehicle life is the life of a vehicle before it needs to be replaced.

Model life determines how long this model is available for sale (without
using persisentengines).  Usually this shoule be at least twice or three
times as  long as the vehicle life.  When starting a new game, a random
amount between 31 months and 17 years is added to this as well.

If the early retirement property (26/1B/16/16) is not set, the model life
works like this:

Phase	Duration		Reliability
  1	7 to 38 months		increases from 48-73% to 75-100%
  2	prop. 04 less 8 years	stays constant at peak, 75-100%
  3	10 to 20.5 years	decreases from peak to 25-50%

(the ranges in time and reliability are randomized at the start of each game)

At the end of phase 3, the model is retired and removed from the purchase
list.  Note that when the model reliability starts dropping in phase 3, so
does the reliability of every single vehicle of this make in the game.

If persistentengines is on, the model never gets to within two years of the
end of phase 2, it is kept in phase 2 as long as at least one vehicle of this
make is in the game.

If the early retirement property is set, the vehicle is retired this many
years before the end of phase 2 (can be negative if desired), but not if
persistentengines would keep the model alive.

	Properties for trains
	05	B	track type (0=railroad, 1=monorail, 2=maglev)
	08	B	AI special flag: set to 1 if engine is 'optimized' for
			passenger service (AI won't use it for other cargo),
			0 otherwise
	09	W	Speed in mph*1.6 (for wagons only if no graphics
				override, then 0=default, FFFF=no limit)
	0B	W	Power (0 for wagons)
	0D	B	Running cost factor (0 for wagons)
	0E	D	Running cost base; for engines either 4C30 (steam),
			4C36 (diesel) or 4C3C (electric); 0 for wagons
	12	B	Sprite ID (FD for new graphics)
	13	B	Dual-headed flag; 1 if dual-headed engine, 0 otherwise
	14	B	Cargo capacity
	15	B	Cargo type
	16	B	Weight in tons, see also prop. 24
	17	B	Cost factor
	18	B	Engine rank for the AI
			(AI selects the highest-rank engine of those it can buy)
	19	B	Engine traction type (steam/diesel/electric/monorail/maglev)
			Also sets sound effect, and visual effect if prop. 22 not set
			00..07=steam, 08..27=diesel, 28..31=electric,
			32..37=monorail, 38..41=maglev; default if unset is steam
	1A	B	Not a property, but an action: sort the current train
			vehicle before train vehicle with the specified number
			Use this when converting waggons to engines or vice versa
	1B (1)	W	Power added by each wagon connected to this engine
			(only applied for wagons with graphics override for this engine)
	1C (2)	B	Refit cost, using 50% of the purchase price cost base
	1D (1)	D	Bit mask of cargo types available for refitting
	1E (2)	B	Callback flags bit mask
			Bit 0	use callback 10 to determine whether vehicle is
				powered for steam/smoke/sparks generation and
				determining whether to use added wagon
				power/weight
				return value interpreted the same as prop 22
				prop 22 is used if callback fails for
				whatever reason
				this callback only happens after loading a game
				or when buying or moving vehicles in the depot
			Bit 1	use callback 11 for wagon length (see prop 21)
				called every time the train leaves a depot or
				is displayed in a depot
			Bit 2	use callback 12 for load amount (see prop 07)
				this callback only happens after loading a game
				or when buying or moving vehicles in the depot
			Bit 3	use callback 15 to find refitted capacity
			Bit 4	use callback 16 for articulated engines
			Bit 5	use callback 19 to show a suffix after the cargo text
	1F (3)	B	Coefficient of tractive effort, that is the ratio between
			maximum tractive effort and weight; FF:TE=W, 80:TE=W/2, etc.
			default is 4C, for TE=0.3*W (Wadh=W and mu=0.30)
	20 (4)	B	Set realistic acceleration air drag coefficient c2
			If unset, or set to 0, TTD will use the following values
			depending on the top speed:
			speed:	<32  32  48  64   96 128  192  256  384  512...
			c2:     192 128 96 64 48  32  24  16  12   8
			air drag in Newtons will then be c2*v*v with v in m/s,
			although it is probably futile to attempt to make c2 a
			realistic number due to the lack of TTd's consistent
			scaling
	21	B	Make vehicle shorter by this amount (e.g. for tenders)
			00=not shorter, 01=shorter by 12.5%, up to 05=shorter by 62.5%
			Does not work for the first vehicle in a consist (i.e. the engine)
	22 (1)	B	Set visual effect type (steam/smoke/sparks) as well as position
			of effect relative to tip of engine; use x0=half length
			before engine, x4=front of engine, x8=middle, xC=end,
			xF=half length after engine or intermediate values
			(positioning currently only works for steam)
			00..0F=use effect from prop 19 (default), 10..1F=steam,
			20..2F=diesel, 30=3F=electric, 40=disable effect
			for wagons, 40=no wagon power/weight is added, and no
			effect is shown, 00..0F=wagon power/weight is added
			but no effect is shown, with all other values wagon
			power/weight is added and corresponding effect is shown
			for wagons, add 80 to this value (or the callback)
			to only show effect, but not to add power and weight
	23 (1)	B	Set how much weight is adding by making wagons powered
			using property 1B, in tons
	24 (6)	B	High byte of vehicle weight, weight will be prop.24*256+prop.16
	25 (7)	B	User-defined bit mask to set when checking veh. var. 42
	26 (8)	B	Early retirement this many years before end of phase 2


	Properties for road vehicles
	08	B	Speed in mph*3.2
	09	B	Running cost factor
	0A	D	Running cost base
	0E	B	Sprite ID (FF for new graphics)
	0F	B	Capacity
	10	B	Cargo type
	11	B	Cost factor
	12	B	Sound effect: 17/19/1A for regular, 3C/3E for toyland
	13	B	Power in 10 hp (only used with rvpower)
	14	B	Weight in 1/4 tons (only used with rvpower)
	15	B	Speed in mph*0.8 (up to 511 km/h, only used with rvpower;
			uses prop.08 if unset; always set prop. 08 too)
	16	D	Bit mask of cargo types available for refitting
			(not refittable if 0 or unset)
	17 (2)	B	Callback flags bit mask
			Bit 2	use callback for load amount (see prop 07)
				this callback only happens after loading a game
				or when buying or moving vehicles in the depot
			Bit 3	use callback 15 to find refitted capacity
			Bit 5	use callback 19 to show a suffix after the cargo text
	18	B	Max. tractive effort, see prop 1F for trains
			Default 4C = 30%
	19	B	Set realistic acceleration air drag coefficient c2,
			see train prop 20 (but with default values being smaller
			by 1/2 to account for the smaller cross section of road
			vehicles)
	1A (5)	B	Refit cost, using 25% of the purchase price cost base
	1B (8)	B	Early retirement this many years before end of phase 2


	Properties for ships
	08	B	Sprite
	09	B	Refittable (0 no, 1 yes)
	0A	B	Cost factor
	0B	B	Speed in mph*3.2
	0C	B	Default cargo type
	0D	W	Capacity
	0F	B	Running cost factor
	10	B	Sound effect type (4=cargo ship, 5=passenger ship)
	11	D	Bit mask of cargo types available for refitting
	12 (2)	B	Callback flags bit mask
			Bit 2	use callback for load amount (see prop 07)
				this callback only happens after loading a game
				or when buying or moving vehicles in the depot
			Bit 3	use callback 15 to find refitted capacity
			Bit 5	use callback 19 to show a suffix after the cargo text
	13 (5)	B	Refit cost, using 1/32 of the default refit cost base
	14 (6)	B	Ocean speed fraction, sets fraction of top speed available
			in the ocean; e.g. 00=100%, 80=50%, FF=0.4%
	15 (6)	B	Canal speed fraction, same as above but for canals
	16 (8)	B	Early retirement this many years before end of phase 2


	Properties for aircraft
	08	B	Sprite
	09	B	Is helicopter? 2=no, 0=yes
	0A	B	Is large? 0=no, 1=yes (=can't safely land on small airports)
	0B	B	Cost factor
	0C	B	Speed in mph*8
	0D	B	Acceleration
	0E	B	Running cost factor
	0F	W	Passenger capacity
	11	B	Mail capacity
	12	B	Sound effect (not for helicopter); 6=prop 1, 7=jet 1,
			3b=supersonic, 3d=jet 2, 45=prop 2, 46=jet 3
	13 (1)	D	Bit mask of cargo types available for refitting
	14 (2)	B	Callback flags bit mask
			Bit 2	use callback for load amount (see prop 07)
				this callback only happens after loading a game
				or when buying or moving vehicles in the depot
			Bit 3	use callback 15 to find refitted capacity
			Bit 5	use callback 19 to show a suffix after the cargo text
				(of the first compartment only, mail will remain unchanged)
	15 (5)	B	Refit cost, using 1/32 of the default refit cost base
	16 (8)	B	Early retirement this many years before end of phase 2


Footnotes:
	(1) This property was introduced in 2.0.1 alpha 6 and 7. To keep your
	    grf file compatible with 2.0 rev 1, set the grf version in action 8
	    to 5, and use this action 7 to skip action 0 which uses these
	    new properties:
		* 9  07 8B 04 04 46 00 0A 02 <num-sprites>
	(2) This property was introduced in 2.0.1 alpha 11, use this action 7:
		* 9  07 8B 04 04 6E 00 0A 02 <num-sprites>
	(3) This property was introduced in 2.0.1 alpha 19, use this action 7:
		* 9  07 8B 04 04 BE 00 0A 02 <num-sprites>
	(4) This property was introduced in 2.0.1 alpha 27, use this action 7:
		* 9  07 8B 04 04 0E 01 0A 02 <num-sprites>
	(5) This property was introduced in 2.0.1 alpha 30, use this action 7:
		* 9  07 8B 04 04 2C 01 0A 02 <num-sprites>
	(6) This property was introduced in 2.0.1 alpha 36, use this action 7:
		* 9  07 8B 04 04 68 01 0A 02 <num-sprites>
	(7) This property was introduced in 2.0.1 alpha 39, use this action 7:
		* 9  07 8B 04 04 86 01 0A 02 <num-sprites>
	(8) This property was introduced in 2.0.1 alpha 44, use this action 7:
		* 9  07 8B 04 04 B8 01 0A 02 <num-sprites>


Note:
	- Trains use FD for new sprite graphics, all other vehicle types
	  use FF.
	- Vehicle costs and running costs are all determined by a factor
	  only, which is then multiplied with a base value that is the
	  same for all vehicles of that type (except trains, where you
	  have a choice of three base values)
	- The refitting bit masks don't work yet for trains and planes
	  but they can be set and will be saved for later
	- Don't use property numbers that aren't defined here

The callback mask is an advanced feature that allows graphics files to change
the behaviour of various patch functions according to the current graphics of
a vehicle, and is therefore especially useful in conjunction with
variational/random graphics.  To use it, the patch sets the corresponding
callback ID in the 0C variable, and starts from the vehicle's action 3
definition, following the chain of action 2 entries until the final decision
is reached.  This final decision is indicated by an action 2 returning a
set-id with the high byte set to 80.  The low byte is then used as return
value of the callback.  Note that at least one action 2 is the chain MUST
check the value of 0C, because a set-id with 80 in the high byte is invalid
for a regular action 2, and may only be returned for callbacks.  Unlike all
other properties, callback flags are not saved with saveoptionaldata on,
because they would not work without the graphics file anyway.  See
callback.nfo at the source code site (in newgrfdemo directory) for examples.
Most callbacks only use the 8 bits of the low byte as return value, but
some use 15 bits, where the upper 7 bits come from bit 0..6 of the high byte
(which has bit 7 set to indicate a callback result).  For example, to return
1104 = 0450h, you would use 50 84.


You can define several new properties for many vehicles using a single
action 0 entry.  For example, the following entry:

* 180	00 02 0A 0B 00
   00	6A 0B	9A 55	90 08	BC 5C	69 43	7B 44	30 4A	23 07	11 39	56 47	EC 3B
   06	07	07	0F	0F	0F	06	03	0F	07	0F	07
   08	FF	FF	04	FF	06	FF	FF	FF	FF	FF	FF
   09	00	00	01	00	00	01	00	01	01	01	01
   0A	9E	BE	60	FF	94	B4	AF	6E	A0	D2	AA
   0F	96	82	5A	FF	BE	BE	B4	A5	A0	78	AA
   0B	45	52	49	6C	E0	55	4D	45	4A	52	4A
   0C	03	03	00	00	00	0B	04	05	06	05	07
   0D	2C 01	C2 01	64 00	F4 01	64 00	18 01	68 01	BE 00	68 01	C2 01	68 01
   11	08 00 00 00
	08 00 00 00
	05 00 00 00
	01 00 00 00
	01 00 00 00
	00 30 20 04
	10 00 00 00
	F6 7F BF FF
	42 41 00 00
	20 30 20 04
	80 0A 01 00

sets all properties for all of the ships at once.  If you can, combine as
many action 0 entries as possible, to save some memory that would otherwise
be wasted.


For train stations (feature 4):
-------------------------------

For stations, the offset defines the first station ID for this action 0.
Station IDs are unique within each grf file, however, in total each game can
(currently) only have 255 station IDs for all active grf files.

The only property you *must* set for each station ID is 08, anything else
can be left at the default.  Property 08 *must* be the first property set for
each station ID, because it's what defines the station ID internally.  Before
setting property 08, the station ID is strictly undefined and invalid.  Also,
all station IDs must have their class set in order, starting from ID 00.

	Properties for stations
	08	D	Class ID, see below
	09	V	Sprite layout, see below
	0A	B	Copy sprite layout, copies sprite layout from stationid
			given by the argument to the stationid given by the offset
	0B	B	Callback flags
			Bit 0	use callback 13 to decide whether to make station
				available in construction menu
			Bit 1	use callback 14 to decide on tile type to draw
	0C	B	Bit mask of disabled numbers of platforms (bits 0..6, 7),
			bit 7 applies for all lengths above 7 (i.e. "+" button)
			at least one of bits 0..3 must be clear
	0D	B	Bit mask of disabled platform lengths (bits 0..6, 7),
			bit 7 applies for all lengths above 7 (i.e. "+" button)
			at least one of bits 0..4 must be clear
	0E	V	Define custom layout, see below
	0F	B	Copy custom layout from stationid given by argument
	10	W	Where to switch from "little" to "lots" of cargo
			(see action 2)
	11	B	Bit mask of tile types (0..7) for which to draw pylons
			(default 0F draws pylons for 0..3, not for 4..7)
	12	D	Bitmask of cargo types that should trigger cargo
			triggers (for random graphics); if this is zero no
			triggers at all will be activated to conserve CPU time
	13	B	General flags
			Bit 0	use different sprite set for ground sprites
				(var. 10 is 1 for ground sprites, 0 otherwise)
			Bit 1	divide cargo amount by station size in action 2
				for better graphical display of cargo amount
	14	B	Bit mask of tile types (0..7) for which *not* to draw overhead wires

Class ID:

TTDPatch groups sets of new station graphics into various classes.  The classes
can be selected by the top row of buttons in the construction window, and the
individual stations within the class from the bottom two buttons.  In addition,
each station can alter its appearance using variational and/or random action 2
entries.

There can be up to 16 different classes at the moment, which are defined
simply by defining new stations for them.  Only two classes are pre-defined:

	Name	Class ID	Intended use for station
	DFLT	44 46 4C 54	Default, no special station type
	WAYP	57 41 59 50	Non-cargo stations, waypoints, signal boxes etc.

WAYP stations will never accept or receive any cargo, and trains with WAYP
stations on their orders will not stop there, independent of the "nonstop"
patch switch.  When combining WAYP and non-WAYP platforms or non-train station
facilities, the first one that is built determines the waypoint status.


Sprite layout:

This controls what sprites are displayed, where they are displayed, and in
what order.  The property is variable sized, and contains the data for
all 8 possible station tile types.  If this property is set, the num-ent in
the corresponding action 1 need not be equal to 12 (hex), it can in fact be
any number, and any number of sprites can be displayed in any order.

The data is specified in this way:

	<num> <data1> <data2> ... <datan>

Here, the meaning is
	V num		Number of different tiles supported
	V data1...	The variable size data for each tile, specified below

Explanation of num
	- Normally this is 8, but you can specify fewer as well
	- Using callback bit 1, specifying more makes sense too
	- If not equal to 8, this value must be the same for all stations set
	  by this action 0
	- To specify 0..254 tile types, simply use that byte value as num
	- To specify 255..32511 tile types, use FF follows by that word value,
	  e.g. for 320 (140 hex) use FF 40 01.

The content of each of the eight data sets is either a new sprite layout:

	D groundsprite	the sprite to draw for the rails; this can only be
			a TTD sprite and can't be replaced by new sprites
	V spritedata	the data for station sprites, see below; each has
			a size of 10 bytes, and there may be several
	B 80		a literal 80 ends the list of sprites for this tile

or, alternatively, the instruction to use TTD's layout by using four zero
bytes 00 00 00 00 instead of the groundsprite bytes.

One can draw two types of sprites.  One type is one that establishes a new
3D bounding box for use by the sprite sorter.  The other type shares the 3D
bounding box of the previous sprite(s).  It must not be larger than the
sprite which established the bounding box, nor must any part of it be outside
this box.  For simplicity, it should have the exact same dimensions as the
sprite it shares the bounding box with.  The latter type is not supported
in the station construction window display.

The spritedata of sprites with their own bounding box has this format:
	B xofs		x-offset from northern tile corner
	B yofs		y-offset from northern tile corner
	B zofs		z-offset from northern tile corner
	B xextent	size of sprite in x direction
	B yextent	size of sprite in y direction
	B zextent	size of sprite in z direction
	D sprite	sprite number to draw

The spritedata of sprites sharing the bounding box has this format:
	B xofs		x-offset relative to previous sprite
	B yofs		y-offset relative to previous sprite
	B 80		a literal 80
	B 00 		(ignored)
	B 00 		(ignored)
	B 00 		(ignored)
	D sprite	sprite number to draw

The sprite number can have the following values (remember to use little endian,
i.e. reversed byte order):
	0000042D+X	use sprite X from the corresponding action 1 block
			(i.e. 0000042D for the first, 0000042E for the
			second, etc.)
	0000842D+X	same, but draw it using company colour translation
	0322442D+X	same, but draw in transparent mode (actual colours
			of the sprite are disregarded entirely); not supported
			in station construction window display

Note that the coordinates here are 3D coordinates with x running from
top-right to bottom-left and y running from top-left to bottom-right.  This
is different to and independent from the x/y offsets used in the actual .NFO
file.  The 3D bounding box is used by TTD's sprite sorter to figure out the
order in which to draw the sprites, as well as telling it which sprites to
draw, because those whose bounding box falls outside the currently updated
screen rectangle will not be drawn.  Make sure the 3D bounding box is large
enough to contain the entire sprite, but not so large that the sprite sorter
can't determine which sprites should be in front.

This means that the order in which you specify sprites is irrelevant.  Sprites
will get drawn from back to front, in the order which the sprite sorter
determines as correct, from their bounding boxes.  The only exception is
sprites sharing the same bounding box, which will always be drawn in the given
order.

Custom layout:

This allows choosing which tile type is built at which tile of a newly built
station.  There are four different types, which TTD normally defines as

	00 = plain platform
	02 = platform with building
	04 = platform with roof, left side
	06 = platform with roof, right side

These numbers are used for stations in NE-SW direction, or these numbers
plus one for stations in the NW-SE direction.  To define a custom layout,
use this format:

	B length	length of platforms for this layout
	B number	number of platforms for this layout
	V tiles		length*number bytes of tile types, one platform after
			another, only 00, 02, 04 or 06 are allowed as values

Repeat this as often as necessary to define the layouts for all supported
combinations of length and number.  End the definitions with a 00 00 (zero
length and zero number).  Any combinations that are not defined will be
built using TTD's default layout.

Note that it may be easier to draw different sprite sets using a variational
action 2 based on station variable 40, rather than redefining the layout.

For canals (feature 5):
-------------------------------

No properties exist for canals.


For bridges (feature 6):
-------------------------------

	Properties for bridges
	08	B	Year of availability, counted from 1920
			(set to 1920 for first bridge if newstartyear<1930)
	09	B	Minimum length, not counting ramps
	0A	B	Maximum length, not counting ramps
	0B	B	Cost factor
	0C	W	Max. speed
	0D	V	Sprite layout, see below
	0E	B	Various flags, bitcoded
			Bit 0	Do not draw the far pillars for higher bridges


Property 0D sets the sprite layout for bridges.  Each part of a bridge has
eight sprites for each of the four types (rail, road, monorail, maglev),
making 32 sprites in total.  Each bridge has 7 parts, though not all of them
have different graphics.

The data for property 0D is variable sized, with the format being

	B tableid	First table to define sprites for
	B numtables	Number of tables to define sprites for
	V spritedata	spritedata, numtables*32 DWORDs with sprite numbers

The tableid is the number of the first table to change.  There are seven
tables for each bridge, with the first six (0-5) being various middle parts
and the last one (6) being the end pieces.

In each middle part table, there are four entries each for the following:
Rail X, Rail Y, Road X, Road Y, Monorail X, Monorail Y, Maglev X, Maglev Y

The four entries are
	Back&Floor, Front, Pillars, 0

Front and Pillars can be 0, meaning no sprite to draw.  The fourth entry
is always ignored.

In the end part table, there are again four entries each, but now for
Rail flat, Rail ramp, Road flat, Road ramp, Monorail flat, Monorail ramp
and Maglev flat, Maglev ramp.

The four entries in this case are
	northern end X, northern end Y, southern end X, southern end Y

The sprite numbers can be any of TTD's sprite numbers.  You can add the
following to get colour translation:
	31D8000h  concrete
	3218000h  red steel
	3208000h  yellow steel

To summarize, there are 7 tables for each of the 11 bridges.  Each table
contains 4*8 entries, making it 128 (80h) bytes large.  The first six tables,
number 0 to 5, are middle pieces, the last table, number 6, is the end pieces.

For town buildings (feature 7):
-------------------------------

For town buildings (or simply houses), the offset defines the first house ID
for this action 0. House IDs, like station IDs, are unique within each grf file,
and in total each game can only have 255 IDs for all active grf files.

To start using a house ID, you must first define it by setting its property 08
(see below). If you try to modify a house ID whose action 08 isn't set, your
request is ignored, but not reported as an error, either. House IDs, unlike
station IDs, need not be set in order, so you can use action 7 to skip action
0-s of the houses you don't currently need (for example those houses that
don't appear on the current climate anyway). You are advised to do so in order
to define as few IDs as possible, leaving space for other GRFs. You don't
need to skip all action 0-s for a house ID to disable it; skipping the action
0 that sets property 08 is enough.

	Properties for town buildings
	number	size	property
	08	B	Substitute building type. This building type will be
			used instead of your new one if your definition isn't
			available for any reason (the grf file is not found,
			for example). Don't set a subtitute building type
			that is larger than your new one (for example, don't
			set 14 (stadium) for an 1x1 building) because this
			may corrupt savegames. Setting this property
			automatically copies every property of the substitute
			building to your new building, so you don't have to
			change properties that are the same as in the substitute.
			House flags 40 and 80 are exceptions; these flags are
			never set automatically. Only the first property 08
			setting copies properties; if you later change it,
			properties will stay.
	09	B	Building flags:
			Bit 0	This is an 1x1 building
			Bit 1	This building can be built only on flat land
				(if clear, foundations are automatically
				displayed on sloped land)
			Bit 2	This is a 2x1 building
			Bit 3	This is an 1x2 building
			Bit 4	This is a 2x2 building
			Bit 5	Animation flag, set in tiles 04 and 05
				(large office block). New buildings have
				a different animation scheme than large
				office blocks, but animation is still enabled
				with this bit.
			Bit 6	This building is a church
			Bit 7	This building is a stadium

			If your building isn't 1x1, set flags accordingly
			for the north tile, then define the next 1 or 3
			tiles (by setting their property 8) with flags set
			to zero. There should be no property 8 setting between
			the first tile and the additional tiles. For 2x2
			buildings, the first additional tile is the east
			one, the second is the west part and the third
			is the south part. You probably want to set the
			substitute for additional tiles to a TTD additional
			tile whose flags are already zero.
			2x2 buildings are always built on flat land no
			matter how bit 1 is set.
			Only one church and one stadium can exist in a town;
			the town won't build buildings with the according
			flag set until the old church/stadium is removed.
			(This can be done by either the town or a player)
			The animation flag works on a per-tile basis, so
			you should enable it for additional tiles of multi-
			tile buildings as well if you want all tiles to be
			animated.
	0A	W	Availablity years. The low byte is the minimum year,
			the high is the maximum. The building can only be built
			between these two years (inclusive). 1920 are added to
			both bytes before using the values. Since the year counting
			stops in 2070 even with eternalgame on, start years below
			150 mean "never", and end years above 150 mean "forever".
			WARNING: Don't set the start year below 1930 (0Ah)
			unless you know what you're doing! If TTDPatch finds
			a building that is available before 1930, it will not
			build old building types until that year, so you have
			to provide at least one custom building type that is available
			before 1930 for every town zone, or TTD may deadlock while
			trying to create a random game or expand a town.
			This setting is ignored for additional tiles (the setting for
			the north tile is used always)
	0B	B	Population. The population of the town will be increased
			by this amount if this building is built. Additional
			house parts should have a population of zero. The higher
			this value is, the more passengers this building generates.
	0C	B	Mail generation multiplier. The higher this value is, the
			more mail the building generates. For multi-tile buildings,
			mail generation is done in per-tile basis, so you can
			specify different values for every tile, altough distributing
			the generation equally between tiles is suggested.

	0D	B	Passenger acceptance (in 1/8 units). Must be between 0 and 8.
	0E	B	Mail acceptance (in 1/8 units). Must be between 0 and 8.
	0F	B	Goods (if positive) or food/fizzy drinks (if negative)
			acceptance (in 1/8 units). Must be between -8 and 8.
			Note that the officefood switch may modify acceptance in
			the sub-arctic and subtropical climates.

			All the above three values can be set independently for
			tiles of multi-tile buildings, since every tile is processed
			individually when determining what a station accepts.

	10	W	Removal rating decrease. The LA rating of the player who destroys
			this building goes down by this amount. Should be set to the same
			value for every tile for multi-tile buildings.
	11	B	Removal cost multiplier. Should be set to the same value for every
			tile for multi-tile buildings.
	12	W	Building name ID. The ID of the text that should be displayed in
			the land query window. The name can also be set by action 4
			(see there). Should be set to the same value for every tile for
			multi-tile buildings.
	13	W	Building availablity mask
			Bits 0..4	which town zones the building can be built in
			Bit 11		can appear in sub-arctic climate above the snow line
			Bit 12		can appear in temperate climate
			Bit 13		can appear in sub-arctic climate below the snow line
			Bit 14		can appear in subtropical climate
			Bit 15		can appear in toyland climate

			This property should be set to zero for additional building tiles.
	14	B	House callback flags
			Bit 0		use callback 17 to decide wether the house can be built
					on a given tile
			Bit 1		use callback 1A to decide the following frame of the
					animations.
			Bit 2		use callback 1B to periodically start/stop the animation
			Bit 3		use callback 1C to change animation state when
					the construction state cahnges
			Bit 4		use callback 1E to decide the color of the building
			Bit 5		use callback 1F to decide the acceptance of the building
			Bit 6		use callback 20 to decide the lenght of the current
					animation frame
			Bit 7		use callback 21 to trigger destruction of building
			Bit 0 is ignored on additional building tiles
	15	B	House override byte. Setting this property makes this building appear
			instead of the given old TTD building type. Setting the property is
			ignored if the given old house type is already overriden. You can
			set this property more than once to override more old building types.
			No new house of the overridden types will be built in towns.
			This property works in a per-tile basis, so you override tiles of
			old multi-tile buildings individually, altough the old type
			will still be built if you don't override its north tile.
	16	B	Periodic refresh multiplier, used for random triggers. See at
			action 2. Must be set for additional house tiles as well if you
			want to randomize tiles independently.
			If callback 1B is enabled in property 14, it is also called after
			re-randomizing random bits.
	17	D	Four colors used for random painting (see action 2). Each byte
			of the dword defines a color, the values are the same as in action 3,
			except that numbering starts from zero instead of 775. If not set,
			this defaults to 04 08 0c 06 (red, blue, orange and green, the
			colors of the modern office building). Can be set to different
			values for tiles of multi-tile buildings.
	18	B	Relative probablity of appearing. Old TTD house types have a
			probablity of 16, and this is the default for new types as well.
			Increase (or better multiply) this value to make your building
			appear relatively more often, or decrease (divide) it to make
			it rarer. If you set this to zero, the house type never appears.
			The minimal useful value 1 means it's sixteen times less probable
			to build this type than a normal type, while the maximum setting
			of 255 means it's almost sixteen times more probable. The
			probablity is relative since the absolute probablity depends
			on the count and probablity of other houses as well: the more
			types are available (and the higher their probablities are),
			the less the chance is that your type will be chosen.
			This setting is ignored for additional tiles.
	19	B	Extra flags
			Bit 0		This building appears during the generation of a
					town, but not later, i.e. will appear in random
					games, but new ones won't be built during the game.
					Useful for buildings that are intended to be historical.
			Bit 1		This building is protected, i.e. towns an AI players
					won't remove it. Human players can still remove it,
					so you may need to set a high remove cost/rating
					to make them think twice.
			Bit 2		Synchronized callback 1B. (for multi-tile buildings)
					If this bit is set, callback 1B will be called
					when the periodic processing reaches the main tile of
					the building, and not when it reaches the current tile.
					This is useful if your animation must run synchronously
					on every tile of the building. If this bit is set,
					callback 1B is called according to the main tile's
					property 16, not the current one, to make sure every
					tile stays in synch.
			For multi-tile buildings, bit 0 is ignored for additional tiles, but
			bit 1 must be set for all tiles to work correctly.
	1A	B	The bottom seven bits define how many frames the animation consists of,
			minus one. (I.e. 0 means 1 frame, 1 means 2 frames etc.) Currently only
			those animations are supported that don't have more than 32 frames, so
			the maximum is 31.
			The highest bit is set if the animation is looping, i.e. it should start
			again from the first frame after showing the last frame. Non-looping
			animations stop after the last frame, leaving it on the screen. Both kinds
			of animations start automatically when the building is created. It's
			recommended to use callback 1B with non-looping animations, so they are
			played multiple times.
	1B	B	Speed of the animation, i.e. the amount of time between switching frames.
			The default value is 2, which means the switch occurs every 108 milliseconds.
			Increasing this value by one doubles the wait, i.e. 3 will cause 216 ms delay,
			while 4 will cause 432 ms, and so on. Values below 2 have the same effect
			as 2, so the default is the fastest possible setting. The maximum is 16, which
			means 1769 seconds (approx. half an hour) delay. Settings above this value
			may cause strange behaviour.
	1C	B	Class of the building type. Types that were given the same class byte are
			considered to be in the same class. If you don't explicitly set this value,
			the type is considered to have no class (it won't be considered to be class
			0). The scope of a class is the current GRF file, so two types are never in
			the same class if they were defined by different GRF files. Currently, this
			property affects variable 44 only.
			This property is a per-tile one, you can set it for additional tiles as well.
			It's a better idea, however, to set it for the main tile only, since var.
			44 counts tiles, not buildings, and you may count multi-tile multiple times
			otherwise.

For global variables (feature 8):
---------------------------------

Feature 8 (which only has action 0, no others) allows writing to some
global variables.

These will be set as long as any of the new graphics features are enabled.

	Properties for global variables
	08	B	49 entries, base cost multipliers in powers of 2.
			value of 08=default, 07=half, 06=quarter, 09=double etc.
			setting these multipliers to values other than 08
			incurs small rounding errors in all costs every time
			the game is saved or loaded (but these will only be
			noticable after many inflation steps)

For industry tiles (feature 9):
-------------------------------

Industry tiles work similarly to town buildings, except that they are not stand-alone. This
means an industry tile can't stand alone, it's always part of an industry. You should
either override an old tile using property 9 or use the tile in a new industry layout
to make it appear on the map.

	Properties for industry tiles
	number	size	property
	08		B	Substitute tile type. This tile type will be
				used instead of your new one if your definition isn't
				available for any reason. Valid values are 00h-AEh.
				Assigning this property copies the properties of the
				old type just like it does with houses.

	09		B	Industry tile override. Works like the house override
				property for houses. Currently this property is the
				only way to make the tile appear in the game.

	0A,0B,0C	W	Tile acceptance. These three words define what cargoes
				the tile accepts, and how much of them. The low byte
				defines the type of the cargo according to the current
				climate, while the high byte defines the degree of
				acceptance in 1/8 units. If you don't need all three
				cargo types, just zero out the high byte of the
				extra properties.

For industries (feature A):
---------------------------

Industries work similarly to town buildings as well, except that the maximum number of
possible industries is 37, and non-overridden original types count towards this limit.
Industries don't have a climate mask; you should simply not define an industry if it
would be for the wrong climate.

	Properties for industries
	number		size	property
	08		B	Substitute industry type. The first assignment of this
				property copies all properties of the old type to
				this new type. Unlike for houses, the substitute type
				won't replace this new type if the definition becomes
				unavailable.
	09		B	Industry type override. The overridden industry type
				won't be built in new random games. If the GRF file
				becomes active after the game was started, industries
				of the overridden new type won't be replaced by the
				new type.
	0a		V	Set industry layout(s), see format below
	0b		B	Industry production flags
				Bit	meaning
				0	extractive industry (e.g. coal mine)
				1	organic industry (e.g. forest)
				2	processing industry (e.g. steel mill)
	0c		W	Industry closure message. The text associated with this
				textID will be shown if the industry announces closedown.
	0d		W	Production increase message. The text associated with this
				textID will be shown if the industry increases production.
	0e		W	Production decrease message. The text associated with this
				textID will be shown if the industry decreases production.
	0f		B	Fund cost multiplier.
	10		W	Two climate-dependent cargo numbers representing the cargo
				types the industry can produce. Unused slots can be filled
				with FFh.
	11		D	Three climate-dependent cargo numbers representing the cargo
				types the industry can accept, plus a fourth filler byte
				which is always ignored. Unused slots can be filled with
				FFh. These cargo types will only be really accepted if
				the according acceptance of the industry tiles adds up
				to 8/8 or more.
	12,13		B	Production multipliers. If nonzero, the industry periodically
				(6 or 7 times in a month) produces the given amount from the
				according cargo type.
	14		B	Minimal amount of cargo distributed. The produced cargo will
				be distributed to stations only after it exceeds this amount.
	15		V	Random sound effects. The data starts with a byte defining
				the number of available effects, then one byte per effect.
				TTD periodically picks one of the available effects randomly,
				and plays it.
	16		3B	Conflicting industry types. 3 bytes define 3 types that won't
				appear in the vicinity of this industry. If a byte has bit 7
				set, the bottom 6 bits are the ID of a new type already defined
				in the current GRF file. If bit 7 is clear, the bottom 6 bits
				specify an old industry type. FFh can be used to fill unused
				entries. You shouldn't modify property 9 after the type has
				been referenced by a property 16.
	17		B	The probability of the industry appearing on the map while
				generating a random game. Old types have this value between
				0 and 10. If this value is nonzero, at least one instance of
				this type is guaranteed to appear on the map.
	18		B	The probability of the industry appearing on the map during
				normal gameplay. Old types have this value between 0 and 10.
	19		B	The color this industry type will appear in the map window
				in the "Industries" mode.
	1A		D	Special industry flags to define special behavior.
				Bit	meaning
				0	The industry periodically plants fields around itself
					(temperate and arctic farms)
				1	The industry cuts trees around itself and produces its first
					output cargo from them (lumber mill)
				2	The industry is built on water (oil rig)
				3	The industry can only be built in towns with population
					larger than 1200 (temperate bank)
				4	The industry can only be built in towns (arctic and tropic
					banks, water tower)
				5	The industry is always built near towns (toy shop)
				6	Fields are planted around the industry when it's built
					(all farms)
				7	The industry cannot increase its production on the temperate
					climate (oil wells)
				8	The industry is built only before 1950 (oil wells)
				9	The industry is built only after 1960 (oil rig)
				10	AI players will attempt to establish air and ship routes
					going to this indstry (oil rig)
				11	The industry can be exploded by a military airplane
					(oil refinery)
				12	The industry can be exploded by a military helicopter
					(factory)
				13	The industry can cause a subsidence (coal mine)
	1B		W	The text ID of the text to be displayed when the industry is
				generated during the game. By default, all industries have
				"New xxx is being constructed near yyy", except forests, that
				have "New Forest is being planted near yyy".
	1C,1D,1E	D	Input cargo multipliers for the three input cargo types. If the
				first (low) word of the property is M1 and the second (high)
				word is M2, and X units of the corresponding cargo is delivered
				to the industry, the output amounts are calculated this way:

				output_type1 = X*M1/256
				output_type2 = X*M2/256

				The default value for old industry types is 0100h,0000h , so
				every unit of input cargo produces one unit of output cargo
				of the first type. Exceptions are temperate banks and oil rigs,
				that have the default value of 0000h,0000h ,so input cargo doesn't
				affect output.

Format of industry layout tables:

	B numlayouts	The total number of layouts following
	D size		The size of the whole definition, excluding numlayouts and size
	V layouts	numlayout layouts, see format below

the format of an industry layout:

As a special case, if the first byte of a new industry layout is FEh, then only two bytes follow:
the industry number and the layout number. The specified layout of the specified old industry
type will be added to the layout list of the current industry. The following applies only if
the first byte wasn't FEh

	B xoffs, B yoffs	Offsets counted from the northernmost tile of the industry,
				specifying the position of the current tile. Both are taken as
				signed integers, but cannot go negative except the special
				case mentioned below.

	B oldtile		An old tile type to be put on the given tile
	--or--
	0xFE,B newtile,0	newtile is the ID of an already defined industry tile. This
				tile type will be placed on the given tile. Newtile is
				followed by a filler byte that is ignored and must be zero.
	--or--
	0xFF			The given tile is checked for clearance, but nothing will be
				placed on it. Useful to ensure some free space around your
				industry. This is the only case where xoffs and yoffs can be
				negative. If xoffs is negative, yoffs must be one lower than
				the wanted value.

The layout consists of a list of the above tile definitions, terminated by two bytes: 0,80h

Action 1:	Define new vehicle sprite blocks.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <01> <feature> <num-sets> <num-ent>

	B feature	feature to define sprites for
			0, 1, 2, 3: veh-type, 4: train stations, 5: canals
	B num-sets	number of sprite sets
	B num-ent	how many entries per sprite set
			For vehicles, this is the number of different
				vehicle directions in each sprite set
				Set num-dirs=8, unless your sprites are symmetric.
				In that case, use num-dirs=4.
			For stations, must be 12 (hex) for the eighteen
				different sprites that make up a station
			For canals, it depends on the canal feature, 
				see action 3
			For houses and industry tiles, this should be between 1 and 4.
				Sprites after the first four are always ignored.
				see action 2 and 3

The following num-sets times num-ent sprites will be real sprites,
not pseudo-sprites.  The first num-ent sprites will be sprite set 0, the
next num-ent sprites will be sprite set 1, and so on up to sprite set
number num-sets - 1.


Action 2:	Define graphics set IDs or randomized/variational set ID lists
~~~~~~~~~

May appear only *after* the sprite block (action 1) it corresponds
to.  It always refers to the most recent sprite block.

Data is <02> <feature> <set-id> <type/num-entries> <feature-specific-data...>

	B feature	see action 1
	B set-id	ID of this particular definition
	B type/num-entries
			if 80 or greater, this is a randomized or variational
			list definition, see below
			otherwise it specifies a number of entries, the exact
			meaning depends on the feature
	V feature-specific-data
			see below

Note that you cannot skip the definition of a set ID using action 7 or 9.
If you try to do that, it will not work they way you would expect.  The best
way is to skip an action 3 conditionally, instead of using action 7 to select
between several definitions of a single set ID number.


For vehicles (features 0, 1, 2 or 3):
-------------------------------------

Data is <02> <veh-type> <cargo-id> <num-loadtypes> <num-loadingtypes> <loadtypes...>

	B veh-type	see action 1
	B cargo-id	ID of this particular definition, must be unique
			for each sprite set
	B num-loadtypes	how many different states of load this set
			can display, while the vehicle is in motion
	B num-loadingtypes
			same as num-loadtypes but shown while vehicle is
			either loading or unloading
	W loadtypes...	number of sprite sets from most recent action 1 for
			each of the states of load; first for the "in motion"
			load states and then the "loading/unloading" load states

A cargo ID defines a super-set of sprite sets that go together to display
a certain cargo type, at various states of motion or loading.  For example,
for a certain vehicle, you might have one cargo ID for coal, one for iron
ore and one for grain.  Several cargo IDs can share sprites, for example
the empty sprite might be the same for several cargo types.

Both the num-loadtypes and num-loadingtypes must not be zero, or a division
by zero may occur.

If there is only one load type, it is shown for all loads
If there are two load types, the first is shown below 50%, the other above 50%
If there are three load types, they are shown above/below 33% and 66%
If there are four load types, they are shown above/below 25%, 50% and 75%
etc...


For train stations (feature 4):
-------------------------------

Data is <02> <04> <cargo-id> <numlittlesets> <numlotssets> <sets...>

	B 04		feature 4=train stations
	B cargo-id	ID of this definition
	B numlittlesets	number of different amounts of cargo to show when there
			is only little cargo waiting
	B numlotssets	same but for lots of cargo
	W sets...	Number of sprite set in most recent action 1, for
			each of the track types

Like for vehicles, this decides the graphics set to use depending on the
amount of cargo waiting.  There are two caveats, though.  Firstly, a station
can have 12 different cargos waiting, not just a single one.  Secondly, the
maximum amount is 4095 for all stations and all cargo types.

Regarding the first issue, the amount of cargo this refers to depends on the
action 3 that triggered this action 2:

- if the cargo type matched exactly, it's the amount of the matching cargo
  (e.g. the action 3 said "for coal, use this action 2")
- if the default was used, it's the amount of all cargo types added together
- if the station is displayed for construction, the maximum amount is shown

Regarding the second issue, TTDPatch introduces the distinction between
"little" and "lots of" cargo.  The amount where this occurs is set by property
10, which is zero by default.  But if set to a non-zero value, for example
200, then the range 0 to 199 is divided by numlittlesets, and the remaining
range 200 to 4095 is divided by numlotssets.  If property 10 is zero, the
"little" sets are never used, and so numlittlesets may be zero.  numlotssets
must never be zero, however.


For canals (feature 5):
-------------------------------

Data is <02> <05> <set-id> 01 00 <set>

	B 05		feature 5=canals
	B set-id	ID of this definition
	B 01		literal 01
	B 00		literal 00
	W set		Number of sprite set in most recent action 1

You will note that this is the same format as for vehicles, but specifying
only a single action 1 set ID to use for the particular canal feature.


For town buildings and industry tiles (features 7,9):
-----------------------------------------------------

Data is <02> <07/09> <set-id> 00 <groundsprite> <buildingsprite> <xoffset>
	<yoffset> <xextent> <yextent> <zextent>

	B 07/09			feature 7=town buildings or 9=industry tiles
	B set-id		ID for this definition
	B 00			Literal 0 (to distinguish this definition from random/variational lists)
	D groundsprite		Ground sprite for the building (see format below)
	D buildingsprite	The sprite of the building (see format below)
				Can be zero to indicate that no building sprite should
				be displayed (useful for early building stages)

	The remaining bytes define the bounding box of the building:

	B xofs		x-offset from northern tile corner (must be below 10h)
	B yofs		y-offset from northern tile corner (must be below 10h)
	B xextent	size of sprite in x direction
	B yextent	size of sprite in y direction
	B zextent	size of sprite in z direction
	(z-offset is always zero for buildings)

The ground and building sprite fields have the following format:
	Bits 0-13:	Sprite number, exact meaning specified by bit 31
	Bits 14-15:	0: draw sprite normally
			1: draw sprite in transparent mode
			2: recolor sprite
	Bits 16-30:	Color translation special sprite number (used only if
			bits 14-15 are set to 2). Must be a regular TTD sprite.
			Useful values (decimal):
			775:	blue->dark blue
			776:	blue->pale green
			777:	blue->pink
			778:	blue->yellow
			779:	blue->red
			780:	blue->light blue
			781:	blue->green
			782:	blue->dark green
			(783:	blue->blue, not too useful)
			784:	blue->cream
			785:	blue->mauve
			786:	blue->purple
			787:	blue->orange
			788:	blue->brown
			789:	blue->grey
			790:	blue->white
			795:	brownish red->blue
			796:	brownish red->brown
			797:	brownish red->white (ignoring original intensity)
			798:	brownish red->red
			799:	brownish red->green
			800:	brownish red->white (darker parts are blueish)
			801:	brownish red->yellow
			802:	makes the whole sprite darker
			803:	maps the sprite to black and white (for the newspaper)

			In the above table, "blue" means the "magic blue" color
			used, for example, on the vehicles, while "brownish red"
			means the "magic" color used on some town buildings
			( on the tall office block, for example).
			Houses: If this field is zero, but recoloring is turned on in
			bits 14-15, there are two possiblities:

				- If you have callback 1E enabled, it is called to
				  determine the color mapping.
				- If callback 1E is disabled or fails, one of the
				  colors specified in property 17 will be chosen randomly.

			Industry tiles: If this field is zero, but recoloring is turned on in
			bits 14-15, the color of the containing industry will automatically
			be applied.
	Bit 31:		If clear, the bottom 14 bits is a regular TTD sprite number. If set,
			the bottom 14 bits is a number of a sprite set in the most recent action 1,
			and the used sprite is decided according to the current construction state
			and the number of sprites in the set:

			- if there's only one sprite, it's used always
			- if there are two sprites, the first is used during
			  construction (stages 0-2), and the second is used for the finished
			  building (stage 3)
			- if there are three sprites, the first will be used in the beginning of the
			  construction (stage 0), the second will be used during the rest of the
			  construction (stages 1 and 2) and the third will be used for the complete
			  building (stage 3)
			- if there are four or more sprites, the first four will be used for the four
			  construction stages. Sprites after the first four are always ignored.

The ground sprite should be exactly the same size and shape as TTD's flat tile.
In general, it shouldn't contain anything that has a Z dimension because any
non-ground sprite will cover it.

Useful values for ground sprites (decimal):
	3924:		bare land
	3981:		grass
	4550:		snow or desert (depending on climate)
	1420:		concrete

Please note that all the ground sprite becomes visible in "transparent
buildings" mode, so you should draw parts that seem to be hidden as well.


Randomized and variational cargo ID lists:
------------------------------------------

If type has bit 7 set, action 2 is interpreted differently,
depending on the value of type.

In that case, it specifies a list of cargo IDs instead, providing an
intermediate step in the sprite determination.  Such a definition can itself
specify randomized or variational cargo IDs, and the chain is followed until
a regular cargo ID (def-type 00) is reached.  Note that the cargo IDs a
randomized or variational definition refers to must have been defined before
that definition, i.e. you can't refer to cargo IDs before they have been
defined.


For type 80 or 83:	list of randomized cargo IDs
----------------------------------------------------

Data is <02> <veh-type> <set-id> <80/83> <random-triggers> <randbit> <nrand> <set-IDs...>

	B feature	see action 1
	B set-id	same as above, can't share the same number with
			another set ID
	B 80/83		literal 80 or 83 (hex) to indicate a randomized
			cargo ID list
			80 means the triggers refer to the vehicle/station itself
			83 means the triggers refer to the engine of the
			   consist of this vehicle (for vehicles), or the
			   corresponding city for stations
	B random-triggers
			a bitmask of triggers that cause the sprite to change
			the meaning is feature-specific, see below
			the only common bit is:
			80	only change if *all* triggers are met,
				by default changes if *any* triggers are met
	B randbit	number of lowest bit to consider for the random number
			should be zero unless this random definition references
			another randomized cargo ID list
	B nrand		how many different randomized cargo IDs to show
			must be a power of two (e.g. 2, 4, 8, 16....)
	W set-IDs	list of nrand different set-IDs from which one
			is chosen randomly with uniform probability

Random triggers for vehicles:
	01	the vehicle gets a new cargo load
	02	the vehicle enters a depot and is serviced
	04	the consist has no more cargo
	08	any vehicle of the consist gets more cargo

	The consist triggers 04 and 08 will trigger for all vehicles in the
	consist with this trigger, and all matching vehicles will be set
	to the same random state.  However, if non-consist triggers match
	later, each vehicle will be re-randomised individually.

Random triggers for stations:
	01	new cargo waiting
	02	no more cargo
	04	train arrives (starts unloading/loading)
	08	train leaves (done unloading & loading)
	10	train loads or unloads cargo

	Note that stations have two sets of random bits.  Bits 0 to 7 are
	a property of the station as a whole, and bits 16 to 19 are different
	for each tile.  To get tile-based randomness, therefore use randbit=10
	and nrand of no more than 16 (since only 4 random bits are available
	per tile).

	Also note that none of the above triggers will actually trigger unless
	prop. 12 has at least one bit set.  Trigger 01 will be triggered for
	any of the cargo types set in prop. 12, but trigger 02 will only be
	triggered if all of those cargo types have no more cargo waiting.

	Triggers 04, 08 and 10 only affect the platform on which they occur,
	as well as the random bits of the station, but not other platforms.

Random triggers for cities:
	none at the moment

Random triggers for town buildings:
	01	the building tile is processed in the periodic tile
		processing loop
	02	the top tile of the building is processed in the
		periodic tile processing loop

	The periodic tile processing loop constantly processes the tiles
	of the map, processing any given tile in every 256 ticks
	(approx. 3.5 TTD days). Since no "real" event happens to town
	buildings, you have only this opportunity to re-randomize the
	look of your building. If every 3.5 days is too fast for you, you
	can multiply the time-out by setting property 16 for the given tile.
	The time-out is 256 ticks*(prop. 16+1), so 0 means every 3.5 days,
	1 means every 7 days, 2 means every 10.5 days and so on. If trigger
	02 is activated, all parts of the building that has this trigger
	set will get the same random bits, allowing you to randomize a
	multi-tile building as one unit. On the other hand, if the tiles
	of a multi-tile building have trigger 1 set, all tiles will be randomized
	individually. Note that all tiles of a multi-tile building
	get the same value when building the building.

Random triggers for industry tiles:
	01	the building tile is processed in the periodic tile
		processing loop

	Trigger 1 works similarly to trigger 1 for houses except that you
	cannot multiply the timeout: it's always 256 ticks

When displaying vehicles in the purchase list, the game will always
show the first cargo-ID listed, not a random one.

If you have several random cargo ID lists in a chain, normally all of
them would check the same bits in an eight-bit randomized value.  To
prevent that, choose randbit such that all random checks are linearly
independent, or at least as independent as possible.  For example,
if one check has 8 possibilities, it needs three bits (values 0-7).
If you have another check, this means you shouldn't use the first
three bits, so set randbit to 3.  Then, if you have another check,
increase randbit again, but make sure not to check for any bits
above bit 7, because those bits will always be zero.

The cargo ID is always randomized when a vehicle is first bought,
but from then on it only changes when any or all of the trigger
conditions are met.


For types 81/82: list of variational but deterministic cargo IDs
----------------------------------------------------------------

Data is <02> <veh-type> <cargo-id> <81/82> <variable> <shift-num> <AND-mask>
		<nvar> <cid-definitions...> <default-cid>

	Each cid-definition (except for the default-cid) is in the
	form <low-range> <high-range> <cargo-ID>

	B veh-type	same as above
	B cargo-id	same as above, can't share the same number with
			another cargo ID
	B 81/82		literal 81 or 82 (hex) to indicate a variational
			cargo ID list
			81 means the following variable refers to the
			   vehicle/station itself
			82 means the following variable refers to the engine
			   of the consist of this vehicle (for vehicles)
			   or the corresponding city (for stations and houses)
			   (undefined for canals)
	B variable	what variable determines the cargo ID to choose
			00 current date (counted as days from 1920)
			01 current year (count from 1920, max. 2175 even with eternalgame)
			02 current month
			03 current climate, 0=temp, 1=arctic, 2=trop, 3=toyland
			09 date fraction, a word value, incremented by 0x375 every engine tick
			0A animation counter, a word value, incremented every tick
			0C current callback ID (feature-specific), set to 00
			   when not in a callback
			10 articulated engine build stage, station sprite set type
			11 current rail tool type (for station callbacks)
			40+x and
			80+x feature-specific property, see below
	V varadjust	adjust variable to a more useful range; either
			B shift-num	number of bits to right-shift the
					variable by (must be less than 32)
			B AND-mask	bit-mask to AND the value of the
					variable with after bit shifting
					use FF to leave all bits as they are
			or
			B shift-num+40	as above but add 40h
			B AND-mask	as above
			B add-val	signed number to add to the variable before
			B divide-val	dividing by this number less than 32
					and returning the division result
			or
			B shift-num+80	as above but add 80h
			B AND-mask	as above
			B add-val	signed number to add to the variable before
			B modulus-val	dividing by this number less than 32
					and returning the modulus (remainder)
			Note that for the add and divide operations, both the
			variable and the divisor are taken to be signed numbers,
			you may need to mask out bit 7 to do an unsigned division
	B nvar		how many different ranges of values there are

	W cargo-ID	cargo-ID to use for this range of values
	B low-range	lower bound of the range of values (inclusive)
	B high-range	upper bound of the range of values (inclusive)

	W default-cid	default cargo ID to use if none of the ranges
			below matches; must be specified even if the ranges
			cover all possible values

Callback IDs stored in variable 0C:
	ID	class		usage
	10	trains		checking whether vehicle should be powered
				(for steam/smoke/spark production and added
				wagon power/weight)
	11	trains		checking wagon length when leaving depot
	12	all vehicles	load amount callback (prop 07)
	13	stations	checking whether station should be available
				in construction menu (non-zero return) or
				not (if callback returns 0)
	14	stations	which tile type to draw, independent of the
				actual tile type; this allows more than the
				regular types 00..07.  Return only even
				numbers, the odd even/ones will be used for
				the appropriate direction
	15	all vehicles	refitted capacity.  Veh. var B9 will be the
				new, climate-specific cargo type or FF when
				only checking for refittability.  The return
				value is used as is, and not divided by 2 or 4
				cargos other than passengers.  This callback
				uses 15 return bits to allow up to 32511
				(7EFF) units.
	16	trains		articulated engines.  If this callback is in
				use, additional vehicles will be added to the
				engine until the callback returns FF.  The
				callback return is interpreted as the ID of
				the vehicle to add.  If 80 is added to the ID,
				the vehicle will be reversed.  Note that
				since the train is not yet built, you cannot
				use train variables in action 2.  Instead,
				use variable 10, which is set to 01 for the
				first articulated part, 02 for the second
				and so on.  Note that the cost for buying and
				selling articulated engines is only that
				for the first piece as displayed in the purchase
				screen.
	17	town buildings	Build callback. This callback is used to determine
				if the given building type can be built on a
				position. It should return a nonzero value to
				allow building and zero to cancel it.
				Since the building is not created yet, you can't
				use variables 40 and 41 (they return zero).
				You can use variable 42, 43, 44, 45 and all
				town variables, though. Property 0A and 13
				are checked even if the callback returns
				a nonzero value, they can cancel building
				as well.
				For multi-tile buildings, this callback
				is always called for the north tile type, but
				the position you can access through variables
				40, 42 and 43 is not guaranteed to be the
				final position of the north tile. It's
				guaranteed, though, that if the building
				really gets built, one of its tiles will
				occupy that tile. So, for example, if you
				return zero for desert tiles, this neither
				means that your building won't occupy any desert
				tiles, nor that its north tile will be on a
				non-desert tile; it only means that at least one tile
				of the building will be on a non-desert tile.
				(e.g. it can still be built on the very edge
				of a desert)
	18	generic		This is a fairly complicated callback, used for
				various AI decisions.  For details please see 
				http://wiki.ttdpatch.net/tiki-index.php?page=Callbacks
	19	vehicles	Cargo text suffix. This callback choses a
				misc grf text (set using action 4 textids D0xx)
				and displays it after the cargo description,
				e.g. after "5 crates of goods", in the refit
				screen and for trains in the purchase window
				as well. While refitting, this callback is
				called first with the subtype (veh.var.F2)
				set to 0 and then with increasing subtypes
				until the callback returns FF.
	1A	town buildings	Called in every animation frame, needs to
				return the number of the next frame to
				display. Additionally, it can return
				these special values:
				FF - stop animation. The current frame stays
				     on screen until the animation is restarted
				FE - continue with next frame as usual. You
				     can return this for stages where you don't
				     want to do anything special
	1B	town buildings	Called periodically, in a time interval specified
				in property 16. Returns the number of the frame
				the animation should jump to, or one of the
				following special values:
				FF - stop animation in its current frame
				FE - start animation with its current frame
				FD - leave the animation in its current state
				     (do nothing)
				( for multi-tile buildings, property 19/bit 2
				  modifies this callback slightly, see details there )

	1C	town buildings	Called when the building changes its construction
				stage ( during normal gameplay, that means exactly
				four times ). Can return the same values as
				callback 1B. Variable 40 contains the new stage.
				You can return FF for stages that don't have
				animated graphics to save resources.

If any of the above three animation callbacks return a nonzero value in the high byte,
it will be interpreted as a sound effect number, and the corresponding sound effect
will be played on the house tile.

	1D	trains		Called for the train engine when attaching a
				new vehicle to the current train.  Return xx to
				disallow attaching and use the D0xx text ID
				as second line of an error message, FD to
				disallow attaching with the standard message,
				FE to allow attaching, or FF to allow attaching
				if the rail types match.
	1E	town buildings	Called to decide what color mapping the building
				should use. Should return the number of the color mapping
				to be used. (For example, 775 for blue->dark blue mapping)
				Can be useful if you want something more complex than four
				random colors. Uses 15 return bits.
	1F	town buildings	Called to decide what the building tile can accept.
				Uses 15 return bits. The returned word should have the
				layout of Sgmp, where the letters mean the following:

				S: 1 if the building should accept food/fizzy drinks
				   instead of goods
				g: If S is 1, the food acceptance in 1/8 units
				   If S is 0, the goods acceptance in 1/8 units
				m: mail acceptance in 1/8 units
				p: passenger acceptance in 1/8 units

				So, for example, giving the ID 8426h means "4/8 goods,
				2/8 mail, 6/8 passenger", while giving the ID 9205 means
				"2/8 food, 5/8 passenger".

	20	town buildings	Called to decide how long the current animation frame should
				last. The value of the delay should be given in the same way
				as for property 1B. Decreasing the return value speeds the
				animation up instantly. Increasing, on the other hand, doesn't
				slow it down instantly: the actual duration of the current frame
				will be somewhere between the old and the new delays. The new
				delay is applied correctly for later frames.

	21	town buildings	Called periodically, in a time interval specified by property
				16. If it returns a nonzero value, the building gets removed
				from the map as if the town decided to destroy it. You can use
				this for example to remove a historical building, since those
				cannot be normally removed by towns.

For all features, the 80+x variables are offsets into the corresponding
structure in TTD's game data.  The 40+x variables are special variables that
are computed on-the-fly, and aren't actually stored anywhere in memory.

Vehicle properties for the variable:
	40	consist position and length
		returns dword 00nnbbff, where ff is the number of vehicle
		within consist counted from engine (front), e.g. engine=0,
		1st wagon/mail comp.=1, 2nd wagon/rotor=2, 3rd wagon=3 etc.,
		bb is the number counted from end, e.g. last wagon=0,
		next-to-last wagon=1 etc., and nn is the total number of
		vehicles in the consist

	41	same as 40, but only counting consecutive vehicles of the
		same ID

	42	consist cargo
		returns dword uurrcctt, where tt is a bit mask of cargos and
		cc is the most common cargo type (same list as in action 3),
		rr is the most common refit cycle of that cargo type, uu is
		a bit mask of the bits defined by train prop. 25, and tt has
		the following pre-defined bits:
			0  Passengers
			1  Mail
			2  Town cargo (Goods,Food,Candy)
			3  Armored cargo (Valuables/Gold/Diamonds)
			4  Bulk freight (Coal,Grain etc.,Ore,Fruit)
			5  Piece goods (Livestock,Wood,Steel,Paper)
			6  Liquids (Oil,Rubber)

		if used with var.action 2 type 81 (vehicle) it returns only
		cargo from this vehicle on, with type 82 (engine) that of
		the whole consist

	43	current player info
		return 00ttmmnn, where nn is the number of the current player
		from 0 to 7, mm is the multiplayer player number with the
		host player (or the single player) being 0 and the client
		player being 1, and tt is the player type with the following
		values:
			0  Player is human player (permanent company)
			1  Player is AI player (not managed)
			2  Player is a human managing an AI company
			3  Player is human player's original company,
			   now temporarily AI controlled

	44	aircraft info
		returns xxxxhhtt, hh=height above ground (more properly above
		height of its shadow, buildings--incl. heliport--don't count),
		tt=cur airport type (0=small, 1=large, 2=heliport, 3=oil rig)

	80+x	x is the offset into the vehicle structure, see struc veh
		in ttdprot.ah, for example:
		B4	current vehicle speed (speed is at 34) [1]
		C0	vehicle age in days (age is at 40)
		C4	year built (counted from 1920)

	[1] Note that the unit of the speed depends on the vehicle type
	    For trains: in mph/1.6
	    For road vehicles and ships: in mph/3.2
	    For planes: in mph*8
	    Also this is only valid for the first engine, not wagons or
	    additional engines.

Station properties:
	40	returns xTNLcCpP, where N is the number of platforms,
		L is their length, C is the platform number currently being
		drawn, and P is the position along this platform.  On the other
		hand, c and p are the same as C and P but counted from the end.
		All of C, P, c and p start counting from zero at the first
		respectively last platform/position.  T is the current tile
		type, and defined outside of callback 14.  x is undefined,
		use a bit mask to remove it if necessary.

	41	same as 40, but returning those number not for the whole
		station but instead for each individually built section
		this variable is only valid for stations built in 2.0.1 alpha 26
		or later

	42	in bits 0-7: terrain type, 0=normal, 1=desert, 2=rainforest, 4=snow
		in bits 8-15: track type, 0=railroad, 1=electric, 2=monorail, 3=maglev

	43	current player info, see vehicle property 43 above

	44	bits 0-1 indicate whether tile is reserved using PBS
		both bits are set if the tile is reserved, and clear if not
		if PBS is off, bit 0 is clear and bit 1 is set to allow an
		easy non-PBS fallback mechanism
		all other bits reserved and must be masked out

	80+x	x is the offset into the station structure minus 10h, see
		struc station in ttdprot.ah, for example
		00	number and length of train platforms
		70	facilities available
		7A	date station was built

Town properties:
	40	Returns how the "largertowns" switch affects this town
			0 means largertowns is enabled, but it won't
			  allow this town to grow larger than usual
			1 means largertowns is enabled, and it allows
			  to grow this town larger
			2 means largertowns is disabled, so no towns
			  are allowed to grow larger

	80+x    x is the offset into the town structure, see struc town
		in ttdprot.ah, for example
		02	population
		14	5 WORD values of the town zone radii
		36	number of buildings

Canal properties:
	40+x	none defined at the moment

	80+x	x is an offset into a generated canal structure, since
		canals do not otherwise have in-game data
		00	Height above ground, top parts of locks have the 
			same height as the lower parts.
		01	Groundtype, 0 normal, 1 desert, 2 rainforest, 
			4 on or above snowline

Town building properties:
	40	bits 0..1:	construction state: 0..2: various states of
				construction, 3: construction finished
		bits 2..3:	A pseudo-random value. It isn't actually
				random, but is derived from the position
				of the building. Old buildings use this
				value to randomize their colors. TTDPatch
				has a better way to randomize things, but
				you can still use that value to mimic
				unpatched TTD behaviour. Note that
				adjacent tiles aren't guaranteed to have
				the same pseudo-random bits

	41	Age of the building in years (or, strictly speaking,
		the difference between the current year and the year
		the building was built). Returns 255 for buildings
		older than 255 years.

	42	Town zone where the building is situated. The value is
		between 0 and 4, where 0 is the outermost zone of the
		town. Smaller towns have fewer zones. Roads are plain
		in zone 0 and 1, paved in zone 2, have trees in zone
		3 and streetlights in zone 4

	43	Ground type, the same as for canals

	44	Returns dword LLllCCcc, where cc means how many buildings
		of the current type can be found in the current town, while
		CC is the same for the whole map. ll and LL are similar to
		cc and CC, but contain the number of tiles that have the
		same class as the current one. For tiles that have no class,
		ll and LL are always zero. Overridden old types	are considered
		to be the new type they were overridden with. During callback 17,
		the current building isn't on the map yet, and therefore isn't
		counted. In other cases, the building count is at least one,
		since the current building is counted as well.
		ll and LL are available in alpha 42 vcs 2 and above only,
		the high word is undefined for older versions.

	45	Town expansion bits
		Bit 0:		Set if TTD is currently creating a random town,
				clear otherwise. PLEASE NOTE: while TTD is
				generating a random town, town variables
				82 (town population) and B6 (number of
				buildings) are incorrect. The population
				counter contains the population of buildings
				generated _yet_, which means the final value
				may be larger than you get. The building count
				variable, on the other hand, is surely higher
				than the final value will be. If you want
				to check these variables during callback 17,
				you may need to check variable 45 as well and
				make adjustments if this bit is set.

		Other bits are currently reserved for future use.

	46	The current animation frame being displayed. If you don't
		use animation callbacks, it's between zero and the value
		set in property 1A. Animation callbacks can set this to
		anything between 0 and 31.

	80+x	None defined, and none ever will because town buildings
		don't have an internal structure. Trying to access these
		variables crashes TTD.

Industry tile properties:
	40	Construction state of the tile: a value between 0 and 3.
	41	Ground type, the same as canals
	42	Current town zone of the tile in the nearest town
		(which is not necessarily the founder town of the industry).
		Zero if the tile isn't in a town. This is mostly useful
		for banks and other urban industries.

Please note that, unlike random graphics, changes of deterministic
building graphics don't automatically redraw the building (except when
the construction state changes, which redraws the building), resulting
in temporary graphics glitches when a visible building changes its
graphics. These glitches can be fixed by scrolling the building out of
view, then back again.

Enabling animation on a house tile by setting properties 9, 1A and probably
1B ensures that property 46 will indeed change with time, and the building
is redrawn every time property 46 changes. This means that you can
use a variational action 2 to choose the current frame according to property
46. Please note that this kind of animation needs more CPU time and more
sprites, so you should prefer palette animation if possible.

When displaying a vehicle in the purchase list, the game will show
those variations based on external variables (dates etc.) correctly,
but variations based on vehicle properties (speed, age etc.) will
always show the first (not the default) cargo-ID.

Since only byte-ranges are supported, you must use the shift-num to
move the value into a useful range.  For example, the vehicle age
is normally a two-byte value.  If you want to specify the age range
15-20 years, the age would be 5479-7305 in days.  To get this to
fit in a byte value, you have to shift it to the right by 5 bits,
yielding 171-228, which introduces a slight rounding error of course.

Then you specify the range 171 (AB) to 228 (E4), for example using this
pseudo-sprite data (parenthesis for emphasis only):

* 17	00 03 81 C0 05 FF 02 (00 00 00 AA) (01 00 AB E4) (02 00)

This will use cargo ID 0 if the age is 0 to 5471 days, ID 1 if the
age is from 5472 to 7328 days, and ID 2 otherwise.


Action 3:	Associate cargo IDs with vehicles
~~~~~~~~~

May appear only *after* all corresponding cargo IDs have been
defined by an action 2 entry in this .grf file.


Data is <03> <feature> <n-id> <ids>... <num-cid> [<cargo-type> <cid>]... <def-cid>

	B feature	see action 0
	B n-id		bits 0-6: how many IDs this definition applies to
			bit 7: if set, this is a wagon override definition (see below)
	B ids		the IDs for which this definition applies
	B num-cid	number of cargo IDs in this definition
			can be zero, in that case the def-cid is used always
	B cargo-type	type of this cargo type (e.g. mail=2, wood=7, see below)
	W cid		cargo ID for this type of cargo
	W def-cid	default cargo ID

For vehicles, the IDs are the vehicle IDs, whereas for stations they are
of course the station IDs defined by action 0.  For canals, they specify
the canal feature IDs (see below). For town buildings, the IDs are the
house IDs, and specifying a house ID that haven't been defined before
(by setting its property 08) doesn't do anything, but doesn't cause an
error, either. Note that you don't necessarily have to assign a cargo
ID to a house ID, the old TTD sprite of the substitute type will be
used if you don't do so. Industry tile IDs work in the same manner.

If n-vid has bit 7 set, this action 3 must immediately follow an action 3.
The engines defined by the first action 3 will then have an override for
wagon sprites.  This means that you can specify here a number of wagons
that will have different graphics when attached to these engines.

These wagons will use the cargo IDs in the second action 3 whenever they are
attached to one of the engine(s) defined in the first action 3.  Additional
action 3 entries may follow, and if they are overrides, they always apply
to the last action 3 that wasn't an override, but they must always follow
one another with no other actions in between.

For example, if the first action 3 defines the graphics for a train engine,
the following action 3 can have bit 7 set in the n-vid byte, and list the
train wagons whose graphics shall be different if attached to that train
engine.

Note that you need to set the wagon's sprite number to FD using action 0,
or it will only show the default sprite.  You do not need to specify any
other cargo IDs for these wagons though, they will happily use the default
sprite if no other definitions exist.

For stations, you can define a special cargo-type of FE which prevents the
default from being used (which would show the sum of all cargo).  Instead,
the given cid is displayed with no cargo at all.

Generic feature callbacks: if you define an action 3 with n-id set to 0, and
consequently no vehicle ids, this definition will be used for feature-specific
callbacks, such as callback 18. The action 2 given here must then return the
desired callback result.  If a result is not a callback result (high byte
is not FF), then the request is passed on to the previous generic callback
handler, i.e. they are checked in reverse order.

For canals, the following feature IDs may be used:

IDs	numsprites	Description
00	04 (4)		Watercliffs
01	18 (24)		Locks
02	0C (12)		Dikes
03	01 (1)		Icons
04	04 (4)		Flat docks

Note that canals,town buildings and industry tiles do not have any cargo,
so you must use num-cid=00 and only specify the default action 2 ID.

Action 4:	Define new vehicle names or other texts.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <04> <veh-type> <language-id> <num-veh> <offset> <data...>

	B veh-type	see action 0
	B language-id	language ID with bit 7 cleared (see below)
	B num-veh	number of vehicles which are getting a new name
	B offset	number of the first vehicle that gets a new name
	S data		new names, each of them zero-terminated, after
			which the next name begins.

Action 4 is only applied if the language-id has a bit set for TTD's
current language.

	Language  Bit  Value
	American  0	01
	English	  1	02
	German	  2	04
	French	  3	08
	Spanish   4	10

Specify a language-id of 1F to apply this action 4 no matter what the
language of TTD is.

The language is determined from the filesize of the TTD executable file.
This means that if TTD Translator has been used to translate this copy,
action 4 will still be applied for the language that the file used to be in,
not the one it has been translated to, of course.

In addition, if bit 7 of language-ID is set, you aren't changing a vehicle
name, but (almost) any arbitrary text of TTD.  In that case, the data is
interpreted slightly differently:

Data is <04> <veh-type> <language-id> <num-entries> <text-id> <data...>

	B veh-type	see below
	B language-id	language ID with bit 7 set
	B num-entries	number of consecutive texts to change
	W text-id	first text ID to change
	S data		new texts, each of them zero-terminated, after
			which the next name begins.

This action is skipped unless the switch for the corresponding new vehicles
has been turned on (i.e., newtrain, newrvs, newships or newplanes).  Use the
special veh-type of "48" (hex) to do this action if *any* of these switches
is on.  This special veh-type is only valid for this particular action.

The text-id numbers are slightly complicated, unfortunately.  There exist
several classes of strings, each which has a number of string entries.  Only
some classes can be changed currently.  If you have the class, the text ID is
calculated as string_class + string_entry_num.  These classes exist in TTD:

	Class	Meaning		Example entry in the american version of TTD
	0000	General		0:Cannot remove obstacles on land
	0800	Bare land info	B:Rough land
	1000	Railroad tracks	0:Land sloped in wrong direction
	1800	Roads		0:Land sloped in wrong direction for road
	2000	Towns		0:Towns, 6:Population
	2800	Trees		0:Plant trees
	3000	Rail station	0:Rail station selection
	3800	Ship depot	0:Ship depot orientation
	4000	Savegames	0:Save game
	4800	Industries	2:Coal mine
	5000	Tunnels		0:Train in tunnel
	5800	Objects		0:Object in the way
	6000	Debugger(??)	0:Debugger
	6800	Difficulty	0:Difficulty level
	7000	Player Info	4:New face
	7800[*] User-defined	e.g. custom train names, signs, etc.
	8000	Vehicle names	0:Kirby Paul Tank
	8800	Trains		0:Train depot
	9000	Road vehicles	0:Road vehicle in the way
	9800	Ships		0:Dock construction
	A000	Aircraft	0:Airport construction
	B000	Disasters	0:Zeppelin disaster at ...

	[*] Strings in this class cannot be changed.  Do not try to do so.

For a full list of all text IDs, read A. Skrobov's textids.zip in the TTDPatch
source code page.

Special TTDPatch text IDs:
	C4xx	Name of station class associated with station ID xx
	C5xx	New station names
		Changes the text "number of platforms" into the given text
		when the station with this ID from the current set is
		selected (i.e. xx=station-id from action 3 and 0)
	C9xx	Name of the house type of this ID. If both property 12 and
		this is set, the latest definition is used always. You should
		prefer setting property 12 instead of this, so executables
		translated with TTD Translator will show the name in the
		current language. However, if you can't find any suitable
		old TTD texts, this can be used to specify your custom name.
		Don't forget to set the same text for all parts of a multi-tile
		building.
	D0xx	Set miscellaneous grf texts


Action 5:	Define new non-vehicle sprite blocks.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <05> <graphics-type> <num-sprites> <other data...>

	B graphics-type	What set of graphics the sprites define.
	B num-sprites	How many sprites are in this set?
	V other data	Graphics type specific data.  Currently unused.

Possible values for graphics-type:
	4  Pre-signal graphics (48 sprites or 112 with semaphores)
	5  Overhead wires and pylons for electrified railways (xx sprites)
	6  Foundations (retaining walls) for building on slopes (42 sprites)
	7  GUI Sprites (3 sprites, sizer, pin and pushed pin)
	8  Canal graphics

Action 5 entries in a .grf file which has a regular GRF ID (not FFFFFFFF)
will always override those from .grf files with a GRF ID of FFFFFFFF (starting
from 2.0.1 alpha 19).


Action 6:	Apply parameter to following pseudo-sprite or sprite.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <06> <param-num> <param-size> <offset> ... <FF>

	B param-num	Number of parameter to substitute (First = "zero")
			Ignored if that parameter was not specified in newgrf.cfg
	B param-size	How many bytes to replace.  If larger than 4, the
			bytes of the following parameter are used.  In that
			case, nothing is applied unless *all* parameters
			were specified.
	B offset	Offset into data from beginning of next sprite
			to place where parameter is to be stored

Notes:

The triplet of number, size and offset can be repeated as often
as necessary, for any kind of values.  The final byte must be
a literal "FF" to indicate the end of the list, as TTDPatch cannot
easily determine the length of a pseudo-sprite.

This action is processed only in the initialization of a .grf file and
is ignored during the activation.  Therefore, to conditionally skip this
action, you must use action 9 and not action 7.


Actions 7, 9:	Skip next n sprites if condition is true.
~~~~~~~~~~~~~

May appear anywhere in the .grf file.

Data is <07/09> <param-num> <param-size> <condition-type> <value> <num-sprites>

	B param-num	See action 6.  The Action 7 is ignored if the parameter
			was not defined at all.
			Additionally, the following values test in-game
			variables:

			83 B current climate, 0=temp, 1=arctic, 2=trop, 3=toyland
			84 B .grf loading stage, 0=initialization, 1=activation
			85 * TTDPatch flags, only for bit tests, see below
			     for a list of defined bit numbers
			86 B road traffic side, bit 4 clear=left, set=right
			87 B reserved
			88 B see if specified GRFID is active (only action 7,
			     not 9; and only valid for condition-types 6 or 7)
			8B D TTDPatch version
			8D B TTD Version, 00=DOS, 01=Windows
			8E D How many pixels to displace sprites in train info windows
			8F D Track type cost multipliers (4 bytes, 3 of them used,
			     either RR MR ML or RR EL MR/ML), value 08=standard rail cost
			92 B Game mode, 0 in title screen, 1 in game and 2 in editor
(only after 2.0.1 alpha 38 vcs 2)
			93 D Tile refresh offset to left
			94 D Tile refresh offset to right
			95 D Tile refresh offset upwards
			96 D Tile refresh offset downwards

			The above four offsets define the size and position of the rectangle
			refreshed when TTD decides to refresh a tile. The basis of the
			calculations is the pixel coordinate of the north corner of the tile.
			After calculating it, TTD subtracts offset_left from it to get the x
			coordinate of the left edge, adds offset_right to get the x coordinate of the
			right edge, subtracts offset_up to get the y coordinate of the top edge
			and adds offset_down to get the y coordinate of the bottom edge. This
			results in refreshing (offset_left+offset_right)*(offset_up+offset_down)
			pixels. The default values of these variables are 31,36,122 and 32,
			respectively.

			Reading these values is not too useful, but you can modify them using
			action D as well, so your sprites that would exceed the original limits
			can still be redrawn and animated properly. Please note that TTD uses
			these values for every tile, so specifying too high values may slow
			the game down. Please also note that these variables are specified as
			dwords for technical reasons, but only the bottom word will be used.

			Since these values are global to the entire game, you shouldn't just
			overwrite them with an action D. Instead, you should first check
			if they're big enough for you by using action 7, and skip your action
			D if they are. This way, the variables will be set to the maximal value needed,
			not just the value needed for the last grf in the list.

			(all other values greater 80 are reserved)

	B param-size	See action 6 (ignored for bit tests, must be 4 for GRFID tests)
	B condition-type
			What condition to test for:
				0  test for bit value being set
				1  test for bit value being unset
				2  param is equal to value
				3  param is not equal to value
				4  param is less than value
				5  param is greater than value
				6  GRFID is active (only for param-num=88)
				7  GRFID is not active (only for param-num=88)
				8  GRF ID is not active yet but will be 
				   activated (only for param-num=88)
	V value		Bit number (a byte), or value to compare with
			If a value is not a bit number, it has as many bytes
			as the param-size specifies.
	B num-sprites	How many sprites to skip if the condition is true
			Special value 00 means skip rest of this grf file

Bit numbers for TTDPatch flags (param-num = 85):
	Bit	Switch (bit set = switch on)
	0C	keepsmallairport
	0E	largestations
	0F	longbridges
	10	loadtime
	12	presignals
	13	extpresignals
	16	enginespersist
	1B	multihead
	1D	lowmemory
	1E	generalfixes
	27	moreairports
	28	mammothtrains
	29	trainrefit
	2B	subsidiaries
	2C	gradualloading
	32	(Set to bit 0 of unifiedmaglev mode)
	33	(Set to bit 1 of unifiedmaglev mode)
	34	bridgespeedlimits
	36	eternalgame
	37	newtrains
	38	newrvs
	39	newships
	3A	newplanes
	3B	signalsontrafficside
	3C	electrifiedrailway
	41	loadallgraphics
	43	semaphores
	4B	enhancegui
	4C	newagerating
	4D	buildonslopes
	4F	planespeed
	50	moreindustriesperclimate	(this and below values only
	51	moretoylandfeatures		 available from 2.0.1 alpha 19)
	52	newstations
	53	tracktypecostdiff
	54	manualconvert
	55	buildoncoasts
	56	canals
	57	newstartyear
	58	freighttrains
	59	newhouses

Format of the TTDPatch version variable: MMmrbbbb
	MM is the major version
	m is the minor version
	r is the revision
	bbbb is the build number

	For example:
	1.9.1 alpha 50 has MM=1, m=9, r=1, bbbb=50*10 or 019101F4
	2.0 beta 4 has MM=2, m=0, r=4, bbbb=4*10 or 02040028
	2.0 final has MM=2, m=0, r=7, bbbb=70 or 02070046
	2.0 rev 1 has MM=2, m=0, r=7, bbbb=80 or 02070050
	2.0.1 alpha 3 has MM=2, m=0, r=10, bbbb=3*10, or 020A001E

	Generally, an alpha/beta version number is encoded in the build
	number. 2.0.1 has r=10 because r>0 was accidentally used by the
	2.0 beta versions and the final.

	This variable is only available since 2.0.1 alpha 3 or 2.0 rev 1.
	If you need it, set the action 8 newgrf version to 5 to prevent
	loading in 2.0 final.

Notes:

Both actions skip a number of sprites if the condition is true.  Action 7
skips are performed always, but action 9 skips are disregarded during
initialization.  This means it is only safe to use action 9 to skip an
action 6 entry.  For all others, you must use action 7, or they will not be
initialized properly.  This is especially true of action 3 (sprite IDs),
which need to be resolved during initialization.  If you skip an action 3
using action 9, the graphics will be incorrect.

Take care that the number of sprites to skip does not end in the middle
of a non-pseudo-sprite block, or TTDPatch will attempt to interpret these
regular sprites as pseudo-sprites, and will most likely crash.  Also don't
skip beyond the end of a .grf file.  If you need to skip the rest of a .grf
file, just use num-sprites = 0.

For condition-type 6 and 7, the jump is not taken if the GRFID doesn't exist.
Only if the GRFID is present in memory (i.e. the corresponding .grf file has
been loaded) *and* the condition is true, is the jump taken.  You can use this
to test for the mere presence of a GRFID, whether it is active or not.  Note
that the mere presence is independent of the order in newgrf(w).cfg, whereas
activation always happens in the order of the entries in newgrf(w).cfg.

See below for what actions can be skipped using either action 7 or action 9:

Action to skip	with 7	with 9
0 (new props)	yes	yes
1 (sprite blk)	yes	yes
2 (cargo ID)	no[*]	no	[*] skip the corresponding action 3 instead
3 (veh ID map)	yes	no
4 (veh names)	yes	no
5 (sprite blk)	yes	yes
6 (apply param)	no	yes
7 (skip sprite)	yes	yes
8 (GRF ID)	yes	yes
9 (skip sprite)	yes[*]	yes	[*] not during initialization, of course
A (repl.sprite)	yes	yes
B (error msg)	yes	yes
C (NOP)		yes	yes
D (set param)	yes[*]	yes	[*] not if parameter will be used in action 6
E (deact.GRFs)	yes	yes
F (town names)	no	yes

Action 8:	Define GRF ID
~~~~~~~~~

Must be the first pseudo-sprite of a .grf file except for one or more
action 7 entries that may (and probably should) come before it.

Data is <08> <version> <grf-id> <name> <info>

	B version	newgrf version, currently 06
	4*B grf-id	globally unique ID of this .grf file
	S name		name of this .grf set
	S info		string describing the set, and e.g. author and copyright

This action is mandatory, grf files missing this action will not load, and
will show a "wrong version" error message.

The version must match or be compatible with the newgrf version of the
intended TTDPatch version, see below.

The grf-id must be a globally unique ID.  To choose an ID, use the initials
of your first and last name as the first two bytes, along with two more bytes
of your own choice as the last two bytes.  For example, if you are
"Foobar Z. Boozle", use 46 42 00 00 for your first file, and 46 42 00 01
for your second one.  If someone else has already used these initials,
please use a different capitalisation or simply two other letters to keep the
IDs unique.  The ID must not be the same as that of any other .grf file,
either yours or somebody else's.  It should however be the same for both
the DOS and Windows versions of a grf file.  If you make an update to a .grf
file and think that it will be backward compatible with the savegames, give
it the same ID as the original file.  To make it necessary to reactivate the
.grf file, use a new ID.

The ID is used to identify the .grf files to activate after loading a
savegame.  When a game is saved, the IDs of all currently active .grf
files will be stored, and when the game is loaded, only those .grf files
with matching IDs will be activated (if they are still available).  For
all other .grf files, this action 8 simply skips the rest of the .grf file,
as if it had been a successful action 7.

A .grf file is considered to be active if its action 8 has been processed
successfully.  This means that you should control activation by placing
an action 7 before the action 8, to skip a .grf file for the wrong
climate, for example.

The GRF ID "FFFFFFFF" is reserved for graphics files that are controlled
by other switches, for example pre-signals, the catenary system or track
foundations on slopes.  These will be loaded and activated whenever they
are in newgrf(w).cfg and their corresponding switch is on, regardless
of whether they were active before or not.

The name should be a short zero-terminated string that describes
the contents of the .grf file.  It is used for the list of items in the
GRF status window.

The zero-terminated info string has no specified format.  It can
contain anything you want to, but if you want to be recognized as the
author of the .grf file, it should be something like
"Copyright (C) 2003 by Foobar Z. Boozle.  All rights reserved."
Optionally you can follow with your contact info and any other
information you want to include in the .grf file.

Newgrf version table

newgrf	compatible
version	with		TTDPatch version
00	00		1.9.1 alpha 27 and earlier
01	00..01		1.9.1 alpha 28 and above
02..04	02..04		2.0
05	02..05		2.0.1 alpha 3, 2.0 rev 1
06	02..06		2.0.1 alpha 13
07-FF	- not defined yet -

Note, because TTDPatch 2.0 is compatible with versions 2, 3 and 4, but
TTDPatch 2.0.1 alpha 3 or 2.0 rev 1 are compatible with versions 2, 3, 4 and
5, use version 2, 3 or 4 for a .grf that is compatible with 2.0 and above,
and use version 5 for a .grf that requires at least 2.0.1 alpha 3 or
2.0 rev 1.  To check the exact version, use action 7 with variable 8D in that
case.


Action 9:	Skip next n sprites if condition is true.
~~~~~~~~~

(See actions 7, 9 above.)


Action A:	Replace arbitrary TTD sprites
~~~~~~~~~

Using this action, you can replace arbitrary sprites in trg1.grf with your
own version.

Data is <0A> <num-sets> <set1> [<set2> ...]
A set is <num-sprites> <first-sprite>

	B num-sets	How many sets of sprites to replace.
			Sets are continguous chunks of one or several sprites.
Then for each set:
	B num-sprites	How many sprites are in this set
	W first-sprite	First sprite number to replace

The sprites with which to replace TTD's sprites then follow this pseudo-sprite,
just like in action 1.  The first of the following sprites will be the first
sprite from the first set, and the following sprites and sets are used in the
order of their appearance.

You can find the sprite numbers by looking in trg1.pcx, they're the little
numbers above each sprite.


Action B:	Generate error or warning message
~~~~~~~~~

This action allows a .grf file to generate an error or warning message, e.g.
to indicate that it needs a more recent version of the patch.

Data is <0B> <severity> <language-id> <message-id> [<message...> 00] [<data...>] 00 [<parnum>]

	B severity	00: notice, contine loading grf file
			01: warning, continue loading grf file
			02: error, but continue loading grf file, and attempt
			    loading grf again when loading or starting next game
			03: error, abort loading and prevent loading again in
			    the future (only when restarting the patch)
	B language-id	see action 4, use 1F for built-in error messages
	B message-id	message to show, see below
	S message	for custom messages (message-id FF), text of the message
			not present for built-in messages.
	V data		additional data for built-in (or custom) messages
	B parnum	see action 6, only used with built-in message 03

TTDPatch has several built-in messages:

	Message-ID	Text
	00		80 " requires at least TTDPatch version " 80 00
	01		80 " is for the " 80 " version of TTD." 00
			<data> should be "DOS" or "Windows"
	02		80 " is designed to be used with " 80 00
			<data> should be a switchname + value, e.g.
			"multihead 0"
	03		"Invalid parameter for " 80 ": parameter " 80 " (" 7B ")" 00
			<data> should be the switch number written out ("5")
			7B is the parameter value, for the parameter number
			specified by parnum
	FF		Custom message, use text from <message>

All messages are prefixed with translated versions of either nothing,
"Warning: " or "Error: " depending on the severity.  In each message, the
first 80 is replaced by the grf file name, and the second 80 is replaced by
the content of <data>.

Warning messages should be used sparingly, because they will be shown again
and again everytime a game is loaded or a new game is started unless the grf
file is built to prevent that (e.g. using a combination of action D and 7).

The advantage of the built-in messages is that they can be translated using
the mkpttxt mechanism, whereas custom messages will only be available in the
languages that come with the grf file.

Note that if several grf files attempt to show error messages, only the first
message is actually shown at the moment.

Also note that since this action has only been introduced in 2.0.1 alpha 13,
it makes no sense to check whether the version is at least alpha 13 if you
want to use the error message 00.  In earlier versions, the patch will display
the "invalid sprite" error message anyway because the action is unkown.


Action C:	Do nothing (NOP)
~~~~~~~~~

This action does nothing at all.  It can be used to temporarily comment out
an action while working on the grf file, or depending on a parameter using
action 6.

Data is <0C> [<ignored...>]

	V ignored	Anything following the 0C is ignored


Action D:	Set parameter value
~~~~~~~~~

This action can be used to set a value of a parameter in newgrf.cfg, either
to a given value or as a result of a simple calculation.

Data is <0D> <target> <operation> <source1> <source2> [<data>]

	B target	parameter number where result is stored
	B operation	operation to perform, see below
	B source1	first source operand
	B source2	second source operand
	D data		data to use in the calculation, not necessary
			if both source1 and source2 refer to actual parameters

	Operations
	00	Set parameter equal to source1
	01	Addition, source1 + source2
	02	Subtraction, source1 - source2
	03	Unsigned multiplication, source1 * source2 (both unsigned)
	04	Signed multiplication, source1 * source2 (both signed)
	05	Unsigned bit shift, source1 by source2 (source2 taken to be a
		signed quantity; left shift if positive and right shift if
		negative, source1 is unsigned)
	06	Signed bit shift, source1 by source2
		(source2 like in 05, and source1 as well)

You can add 80 to the operation to make it apply only if the target is not
defined yet.  In this respect, a parameter is taken to be defined if any of
the following applies:
	- it has been set to any value in the newgrf(w).cfg parameter list
	- it OR A PARAMETER WITH HIGHER NUMBER has been set to any value by
	  an earlier action D

If, for example, parameters 0 and 1 are set in the newgrf(w).cfg file, and
action D sets parameter 4, then parameters 2 and 3 automatically become
defined and get a value of zero.

The source1 and source2 operands refer to the grf parameter number like
in action 6 and 7.  In addition, they can refer to the special variables
available in action 7, or they can be FF to use the value of <data>.  If
referring to parameters that are undefined, a value of 0 is used instead.

Only in 2.0.1 alpha 16 or higher: you can access the parameters of another
GRF file by using source2=FE, source1=the other GRF's parameter number and
data=GRF ID.  This is only valid with operation 00 (set).  If the GRF ID
cannot be found, a value of 0 is used for the parameter value instead.

The target operand can also refer to the special variables from action 7,
but at the moment the only variables that is valid to write are 8E,8F and
93-96.

Because the patch has to reallocate memory for the whole parameter list
whenever a new parameter is added, you should set the parameter with the
highest number first (whenever possible, at least) so that all memory can
be allocated right away.

Note that parameters are never reset after the game has started, therefore
you must not modify newgrf(w).cfg parameters with any kind of irreversible
operation.  It is valid to, for example, add a value to a parameter only if
the same value is later subtracted, to keep the parameter the same across
loading or starting several games.


Action E:	Deactivate other GRF file or force activation of current file
~~~~~~~~~

This action can be used to deactivate an earlier, incompatible version of
a GRF file, or any other GRF file in general.

Data is <0E> <num> <grfids...>

	B num		Number of GRFIDs that follow
	D grfids	GRFIDs of the files to deactivate

Normally, graphics files should use action 7 to deactivate themselves, if
they find that other incompatible graphics have been loaded.

However, when new sets come out, it is often not feasible to change all
existing sets so that they can detect the new set.  This action therefore
allows the new graphics set to deactivate older sets with which it is
incompatible.

Note that it is invalid to attempt the deactivation of already active
graphics files.  You can only prevent files lower down the newgrf(w).cfg from
becoming active later. Therefore, you must check that none of the GRF IDs in
this list are active already using the appropriate action 7.  If the
deactivation of an already active set is attempted, the current set (i.e. the
one containing the action E) is considered invalid and will be disabled.

To handle the cases of incompatible sets being loaded and activated earlier,
you can either attempt to overwrite all their settings and graphics, or
simply deactivate this set in turn.

If the given GRFID is identical to the GRFID of the file currently being
processed, the current file is force-activated.  This is most useful for
making changes to the title screen menu, which would otherwise not be
possible.  It is strongly recommended not to use this feature in any way
other than in combination with an action 7 that checks variable 92 (game
mode) so that the activation only happens in the title screen.  Otherwise
the GRF Status Windows (de)activation is bypassed entirely.

It is best to limit this forced activation to as few actions as possible
for maximum compatibility.


Action F:	Define new town name styles
~~~~~~~~~

This action can be used to define new town name styles for random games.

Data is <0F> <ID> [ [<langs> <name>]... 00 ] <num-parts> [ <textcount> <firstbit> <bitcount>
	 [ <probablity> <part/ID> ]... ]...

	B ID		ID of this definition in the bottom 7 bits. If bit 7 is set, this is a final
			definition (it will be displayed in the Options window), if it's clear, this
			is an intermediate definition that can be used to create more complex decision
			chains (see later). Final and intermediate definitions share the same 128
			IDs, so 01h and 81h define the same ID for different usages, and not two
			separate IDs.
-- The following three fields are present in final definitions only

	B langs		Bit mask of languages in which the following style name can be displayed.
			It's in the same format as for action 4, except that bit 7 is ignored.

	S name		Null-terminated style name to be displayed in the Options window.

	00		After defining all the necessary mask-name pairs, a literal 00 terminates
			the style name definition. If no appliable name is found, "(unnamed style)"
			will be displayed in the Options window.

-- End of style name fields

	B num-parts	How many parts this name is put together from.

-- The following fields are repeated for every part (num-parts times)

	B textcount	The number of possible values for this part

	B firstbit	Number of the lowest bit that counts for determining the value of the part.
			Every town has 32 random bits for random naming. You can use this field
			to make the decisions for every part linearly independent, or at least as
			independent as possible

	B bitcount	How many bits are used for determining the value of this part. The minimal
			number should be the lowest power of 2 that is higher than the sum
			of all probablities (e.g. 2 if the sum is <=4, 3 if it's <=8, 4 if <=16
			and so on), but allowing more bits can make the distribution of decisions
			smoother.

-- The following fields are repeated for every text (textcount times) in every part

	B probablity	The relative probablity of the following name to appear in the bottom 7 bits.
			Bit 7 decides the meaning of the following field.

	S part		If bit 7 of probablity is clear, the following field is a null-terminated
			string containing a name part itself. This can be an empty string (just
			a plain zero byte) to avoid generating this part. (This can be useful
			for an optional part: give a high probablity to an empty part to appear,
			and low probablities to many non-empty parts, so you effectively decrease
			the chance that the part appears at all)

	B ID		If bit 7 of the probablity is set, the following byte is an ID for an
			intermediate action F. The random name defined by the given ID is generated,
			then inserted into the current name as a name part. Specifying an ID that
			isn't defined yet results in an error and therefore disabling all town
			name definitions in the file.

Note that town name styles are special since they have to be available on the title screen as well,
where the graphics files aren't activated yet. This means they're processed at the initialization
stage only, and can be skipped only by action 9, but doing so will prevent them from working for
the rest of the game. The only way to disable a new town name style once it's loaded is to disable
the entire GRF file it's situated in (by using the "New GRF status" window or by putting an exclamation
mark next to the filename in newgrf(w).txt).

A town name generated this way must meet some requirements to be accepted by TTD: it can't be empty
(so you don't have to worry even if your chain can generate an empty string), can't be a name that's
already given to a town (to avoid duplicate town names),  can't be longer than 31 characters and 
its displayed form can't be wider than 130 pixels. If a generated name doesn't meet all these
requirements, TTD tries again with a different random value. For this reason, your town name style
must be able to generate at least 70 different acceptable combinations, since this is the maximum number of
towns possible on a map, and TTD may deadlock if it can't find different names for every town on
the map.

The town name style dropdown menu doesn't support more than 19 entries, and since six entries are
already reserved for the old styles, only 13 remain for new styles. If there are more than 13 final style
definitions available, only the first 13 will be displayed in the dropdown menu, and therefore be
selectable. The other definitions will still be available (e.g. they'll show up in games started with them),
but cannot be selected from the user interface.

If your GRF isn't available while its name style definition is used in a savegame, the town name style
reverts back to German, but the towns get both English and German names; they appear in the wrong order
in the town list and duplicate town names may appear. However, no data loss occurs, so the correct
names are restored as soon as your definition becomes available again.

4)  General information and hints and tips
------------------------------------------

a) An example .nfo file

Here's the simplest possible complete .nfo file.

It defines one train engine, no stats modified, 8 different directions
(i.e. not symmetric like the SH 40), no differences based on cargo type
or other factors.

You must include the first three comment lines or the file won't work.

---8<---cut here---8<---
// Automatically generated by GRFCODEC. Do not modify!
// (Info version 4)
// Format: spritenum pcxfile xpos ypos compression ysize xsize xrel yrel
  0 * 4  0D 00 00 00
  1 * 8  08 04 XX XX XX XX 00 00
  2 * 7  00 00 01 01 XX 12 FD
  3 * 4  01 00 01 08
  4 SPRITES\train.pcx 98 8 01 18 8 -3 -10
  5 SPRITES\train.pcx 114 8 09 14 20 -14 -6
  6 SPRITES\train.pcx 146 8 01 12 28 -14 -6
  7 SPRITES\train.pcx 194 8 09 16 20 -4 -8
  8 SPRITES\train.pcx 226 8 01 18 8 -3 -10
  9 SPRITES\train.pcx 242 8 09 16 20 -14 -7
 10 SPRITES\train.pcx 274 8 01 12 28 -14 -6
 11 SPRITES\train.pcx 322 8 09 14 20 -4 -6
 12 * 9  02 00 00 01 01 00 00 00 00
 13 * 7  03 00 01 XX 00 00 00
---8<---cut here---8<---

Instead of the XX XX XX XX in sprite #1, use your own graphics ID.  See
action 8 on how to decide what it should be.

For the XX in sprite #2 and #13 substitute the train engine number you want
to change, e.g. use 00 to replace the Kirby Paul Tank.

You will probably have to modify the PCX file name, the X and Y coordinates
of the sprites (first two numbers after the PCX file name), as well as the
X and Y offsets (last two numbers).  Possibly the X and Y sizes too.

A very brief summary of the pseudo sprites:
 #0: define how many sprites are in the file (13 decimal=0D)
 #1: action 8; set the GRFID of this .grf file, and define the version
 #2: action 0; set the train engine properties (in this case the sprite)
 #3: action 1; declare the next 8 sprites as actual vehicle sprites
 #4 through #11 are therefore vehicle sprites
#12: action 2; declare cargo ID 0
#13: action 3; attach cargo ID 0 to the engine

If you want to modify the train properties (currently only the sprite
prop. 12 is set to FD), change the second 01 in sprite #2 to the number of
properties, add them at the end of the line, and adjust the number of
bytes (now 7).

If you want to make it look different depending on cargo, add them after
sprite #11, and modify sprite #3 appropriately.  Then define more cargo IDs
using action 2 and tell action 3 when to use which ID.  Don't forget to
adjust the total number of sprites specified in sprite #1.



b) The following cargo types are defined by TTDPatch:

Num1	Bitval	Num2	Type
 00	1	 00	Passengers
 01	2	 01	Coal
 02	4	 02	Mail
 03	8	 03	Oil
 04	10	 04	Livestock
 05	20	 05	Goods
 06	40	 06	Grain/Wheat/Maize
 07	80	 07	Wood
 08	100	 08	Iron Ore
 09	200	 09	Steel
 0A	400	 0A	Valuables/Gold/Diamonds
 0B	800	 09	Paper
 0C	1000	 0B	Food
 0D	2000	 04	Fruit
 0E	4000	 08	Copper Ore
 0F	8000	 09	Water
 10	10000	 01	Rubber
 11	20000	 01	Sugar
 12	40000	 03	Toys
 13	80000	 04	Batteries
 14	100000	 05	Candy (Sweets)
 15	200000	 06	Toffee
 16	400000	 07	Cola
 17	800000	 08	Cotton Candy (Candyfloss)
 18	1000000	 09	Bubbles
 19	2000000  0A	Plastic
 1A	4000000	 0B	Fizzy Drinks
 1B	8000000  0B	Paper (only in temperate climate, with moreindustriesperclimate switch)
 1C	10000000 08	undefined; unused slot in arctic climate
 FF	n/a	 n/a	Shown in purchase list


Num1 is what you use in action 3.
Bitval is (1<<Num1), and it is what you add up to make the bit mask for action 0.
Num2 is what you use as cargo type in action 0.

Note that using a cargo type of FF in action 3 allows you to decide which
cargo ID to show in the purchase list.



c) General strategy for implementing new graphics in the .grf file:

1) First sprite is special, defining the total number of entries in the .grf
   file
2) Start with one or more action 7 entries that decide whether or not to
   load these graphics, for example based on the current climate.
3) After the action 7 entries, define your GRF ID with action 8.
4) Then define one or several action 0 entries, that (possibly among other
   things) set the vehicle sprite IDs to FD (trains) or FF (all other vehicle
   types).  Only vehicles with these sprite IDs will be using the new sprites.
5) Start a block of new graphics with an action 1 (sprite block) entry,
   followed by the actual sprite data.  Ideally, you put the graphics of all
   vehicles together in this one sprite block, taking note of what sets of
   sprites have what number (as determined by their position in the block).
6) After action 1, give action 2 (cargo ID) entries for each different
   combination of vehicle and cargo type.  The cargo IDs should start at zero
   and be numbered consecutively.
7) After all action 2 entries, use action 3 (veh ID to cargo ID maps) to
   specify what cargo IDs are to be shown for which vehicle and which cargo
   types.



d) Dealing with the sprite numbers and pseudo-sprite blocks

It can be quite a chore to make sure that the sprite numbers increase
by one, and that you have the correct length for the pseudo-sprite blocks.
Currently, GRFCodec has only limited parsing capabilities, so you need to
make sure that they are indeed correct.  Note that as of GRFCodec version
0.9.4, you can specify a sprite number of "-1", which turns off the number
checking for that sprite.  The following sprites still need correct numbers
(unless they also have "-1" as the number), and the sprite length still
needs to be specified.

One help in this task is a Perl script called renum.pl, which you can find
in this directory.  If you haven't heard of Perl before, it's a powerful
programming language that you can get for free.  For example, you can
install it with the Cygwin packages (www.cygwin.com), or from activestate.com
and perl.com.

If you have written a .nfo file, but it doesn't have the right numbers for
the sprites or the lengths, run the renum.pl script like this:

perl renum.pl < your.nfo > yournew.nfo

It will take the your.nfo (substitute your actual filename), and write
yournew.nfo with correct sprite numbers and pseudo-sprite lengths.

Note that the format of the .nfo needs to be correct for this to work
properly; in particular, the sprite numbers and pseudo-sprite lengths must
already be *there* (as dummy numbers), but they need not be correct.



e) How to only load your graphics in some circumstances

For example, you only want your graphics to be active in the right climate,
or only if some other condition is true.

For this, the first entries in your .grf file must be actions 7 which test
that condition, and skip the rest of the file if true.  To skip the rest
of the file, remember to specify a <num-sprites> parameter of 00.

Immediately *after* your initial action 7 entries, you place the action 8
that defines your GRF ID.

This way, the .grf file is considered active or inactive in the right
circumstances.



f) The two stages of loading a .grf file

Every .grf file is processed in two stages.  The first stage, initialization,
is run only once.  In this stage, TTDPatch records the GRF IDs, and resolves
all cargo IDs and sprite IDs as well as doing some other bookkeeping tasks.

During initialization, actions 0, 3, 4, 5 and 7 are ignored.  Action 6 is
carried out *only* during initialization.  Action 7 is ignored because
otherwise the sprite IDs and cargo IDs that are skipped won't be resolved.
Action 8 has the GRF ID recorded so that it can be looked up later.

A .grf file is activated only if it was active when the game was started.  If
a game is loaded, only its active .grfs will be reactivated, unless
"loadallgraphics on" is used.  A .grf file is considered active if its
action 8 has been processed, i.e. its action 8 hasn't been skipped using
an action 7.

During activation, only actions 0, 3, 4, 5, 7, 8, 9 and 0A are carried out.
All others are ignored, because they only need to be processed once at
initialization.



g) Final words

Now, after reading all this, go back to section 1, and see if you can
understand how that pseudo-sprite works.  Then all should be clear!
