How to define new graphics
==========================

The new graphics are controlled by newgrf.txt, which is simply a list
of .grf files to include.  Each .grf file can then define graphics for
one or more vehicles.

In this document, you can find out how to define new sprites and
control how they are displayed.

Table of Contents

1)  Introduction to Pseudo-Sprites
2)  Definition of pseudo-sprites
3)  Pseudo-sprite actions
4)  General information and hints and tips



1) Introduction to Pseudo-Sprites
---------------------------------

Pseudo-Sprites are special entries in the .nfo file that corresponds to
a .grf file when decoded by GRFCodec.  They are the entries that do not
have an actual picture in a PCX file, and they start with an asterisk,
instead of the PCX file name.

This is what a regular sprite looks like:
    7 SPRITES\newship.pcx 162 200 09 46 72 -6 -7

This is what a pseudo-sprite looks like:
  125 * 17	 02 02 01 02 04 00 00 01 00 02 00 06 00 07 00 08 00

In each line, the first number is the sprite number.  It must increase
in consecutive integer numbers, starting from 0 for the first entry.

For regular sprites, the next part of the line is the PCX file name,
and the dimensions and offsets of the sprite.

For pseudo-sprites, the entry after the asterisk is the total length
of the pseudo-sprite data, in bytes.  After it follows the actual data,
also in individual bytes.  Note that the length must be given in decimal
notation, but the data is given in hexadecimal notation.

Pseudo-sprites exist in TTD's .grf files too, but their format is
unknown.  In a .grf file used by TTDPatch, however, the format is
described in the next section.  For example, you will find that the
example pseudo-sprite above means to TTDPatch:
	- this is the definition of a cargo ID for ships
	- it defines cargo ID number 1
	- there are two different sets of sprites for ships that are in motion
	- there are four different sets for ships being loaded or unloaded
	- after which follow the numbers of the sprite sets


2)  Definition of pseudo-sprites
--------------------------------

Each pseudo-sprite that is read by TTDPatch has the following format:

<sprite-num> *   <length>  <action> <data>

	sprite-num	The consecutive number of the sprite (see above)
	length		Total size of the pseudo-sprite, including the
			action byte and all data bytes
	action		Defines the action that this pseudo-sprite carries out


The following actions can be specified:

      Action	What it does
	0	Change vehicle info (like TTD Alter)
	1	Define new sprite block
	2	Define new cargo ID: mapping of cargo type and load status to sprite
	3	Define vehicle to cargo ID mapping
	4	Define new vehicle names
	5	New graphics such as pre-signals and overhead wires
	6	Apply newgrf.txt parameter to following sprite data
	7	Skip following sprites if condition is true
	8	Define the GRF ID, description and copyright info


The format of the data of each action is different depending on the action,
and is described below.

These descriptions of the parameters are organized in this manner:

	Size  Name  Description

The size can have the following values:
	B	This parameter is a single byte
	W	This parameter is a two-byte word, specified in little-endian
		byte order, that is, low-byte first, followed by the high-byte
	D	This parameter is a four-byte dword, again in little-endian
		byte order, with the least significant byte first and the
		most significant byte last.
	S	This parameter is variable-length, zero terminated text string
	V	This parameter has a variable length, which depends on one
		of the previous parameters; it will be described there.


Each sprite in the .grf file is such a pseudo-sprite, except for the
graphics sprites preceeded by actions 1 or 5.

The first (pseudo-)sprite has a special format.  It defines how many entries
the .grf file contains in total.  TTDPatch needs to know that, because it
needs to reserve memory for each sprite in the file.

This is the format of the first sprite:

	*   4  <num-entries>

	D num-entries	The total number of sprites and pseudo-sprite
			in this .grf file.  May be slightly larger than
			the actual number, but must not be smaller.

If you give a number that's too large, you're wasting memory that may
be needed for actual sprites, and if the number is too low, the last
few sprites will have to be skipped, which may confuse TTDPatch.


3)  Pseudo-sprite actions
-------------------------


Action 0:	Define new vehicle properties.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <veh-type> <num-props> <num-info> <offset>
then repeated numprops times: <property> <new-info>

	B veh-type	0, 1, 2 or 3 for trains, road vehicles, ships or planes
	B num-props	how many properties to change
	B num-info	how many vehicles to change
	B offset	offset into each property (i.e. how many vehicles
			to skip before the first one to change)
	B property	what property to change, depends on the veh. type
	V new-info	new bytes of info (variable size)

	Properties common to all vehicle types
	number	size	property
	00	W	date of introduction (will have random amount added)
	03	B	vehicle life in years
	04	B	engine life in years
	06	B	climates available (bit mask)

All of the above only apply to new games, or when using Cht: ReloadEngines.

Vehicle life is the life of a vehicle before it needs to be replaced.
Engine life determines how long an engine is available for sale (without
using persisentengines).


	Properties for trains
	05	B	track type (0=railroad, 1=monorail, 2=maglev)
	08	B	AI special flag: set to 1 if engine is 'optimized' for
			passenger service (AI won't use it for other cargo),
			0 otherwise
	09	W	Speed in mph*1.6 (0 for wagons)
	0B	W	Power (0 for wagons)
	0D	B	Running cost factor (0 for wagons)
	0E	D	Running cost base; for engines either 4C30 (steam),
			4C36 (diesel) or 4C3C (electric); 0 for wagons
	12	B	Sprite ID (FD for new graphics)
	13	B	Dual-headed flag; 1 if dual-headed engine, 0 otherwise
	14	B	Cargo capacity
	15	B	Cargo type
	16	B	Weight in tons
	17	B	Cost factor
	18	B	Engine rank for the AI
			(AI selects the highest-rank engine of those it can buy)
	19	B	Steam/smoke/sparks type and sound effect for new graphics;
			00..07=steam, 08..27=diesel, 28..31=electric,
			32..37=monorail, 38..FF=maglev; default if unset is steam
	1A	B	Not a property, but an action: sort the current train
			vehicle before train vehicle with the specified number
			Use this when converting waggons to engines or vice versa
	21	B	Make vehicle shorter by this amount (e.g. for tenders)
			00=not shorter, 01=shorter by 12.5%, up to 07=shorter by 87.5%
			Does not work for the first vehicle in a consist (i.e. the engine)


	Properties for road vehicles
	08	B	Speed in mph*3.2
	09	B	Running cost factor
	0A	D	Running cost base
	0E	B	Sprite ID (FF for new graphics)
	0F	B	Capacity
	10	B	Cargo type
	11	B	Cost factor
	12	B	Sound effect: 17/19/1A for regular, 3C/3E for toyland
	13	B	Power in 10 hp (only used with rvpower)
	14	B	Weight in 1/4 tons (only used with rvpower)
	15	B	Speed in mph*0.8 (up to 511 km/h, only used with rvpower;
			uses prop.08 if unset; always set prop. 08 too)
	16	D	Bit mask of cargo types available for refitting
			(not refittable if 0 or unset)


	Properties for ships
	08	B	Sprite
	09	B	Refittable (0 no, 1 yes)
	0A	B	Cost factor
	0B	B	Speed in mph*3.2
	0C	B	Default cargo type
	0D	W	Capacity
	0F	B	Running cost factor
	10	D	Bit mask of cargo types available for refitting


	Properties for aircraft
	08	B	Sprite
	09	B	Is helicopter? 2=no, 0=yes
	0A	B	Is large? 0=no, 1=yes (=can't safely land on small airports)
	0B	B	Cost factor
	0C	W	Speed
	0E	B	Running cost factor
	0F	W	Passenger capacity
	11	B	Mail capacity
	12	B	Sound effect (not for helicopter); 6=prop 1, 7=jet 1,
			3b=supersonic, 3d=jet 2, 45=prop 2, 46=jet 3


Note:
	- Trains use FD for new sprite graphics, all other vehicle types
	  use FF.
	- Vehicle costs and running costs are all determined by a factor
	  only, which is then multiplied with a base value that is the
	  same for all vehicles of that type (except trains, where you
	  have a choice of three base values)
	- Don't use property numbers that aren't defined here

You can define several new properties for many vehicles using a single
action 0 entry.  For example, the following entry:

* 180	00 02 0A 0B 00
   00	6A 0B	9A 55	90 08	BC 5C	69 43	7B 44	30 4A	23 07	11 39	56 47	EC 3B
   06	07	07	0F	0F	0F	06	03	0F	07	0F	07
   08	FF	FF	04	FF	06	FF	FF	FF	FF	FF	FF
   09	00	00	01	00	00	01	00	01	01	01	01
   0A	9E	BE	60	FF	94	B4	AF	6E	A0	D2	AA
   0F	96	82	5A	FF	BE	BE	B4	A5	A0	78	AA
   0B	45	52	49	6C	E0	55	4D	45	4A	52	4A
   0C	03	03	00	00	00	0C	04	05	06	05	07
   0D	2C 01	C2 01	64 00	F4 01	64 00	18 01	68 01	BE 00	68 01	C2 01	68 01
   10	08 00 00 00
	08 00 00 00
	05 00 00 00
	01 00 00 00
	01 00 00 00
	00 30 20 04
	10 00 00 00
	F6 7F BF FF
	42 41 00 00
	20 30 20 04
	80 0A 01 00

sets all properties for all of the ships at once.  If you can, combine as
many action 0 entries as possible, to save some memory that would otherwise
be wasted.


Action 1:	Define new vehicle sprite blocks.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <veh-type> <num-sprites> <num-dirs>

	B veh-type	same as action 0
	B num-sprites	number of sets of num-dirs sprites
	B num-dirs	how many different vehicle directions in each sprite set
			Set num-dirs=8, unless your sprites are symmetric.
			In that case, use num-dirs=4.

The following num-sprites times num-dirs sprites will be actual sprites,
not pseudo-sprites.  The first num-dirs sprites will be sprite set 0, the
next num-dirs sprites will be sprite set 1, and so on up to sprite set
number num-sprites - 1.


Action 2:	Define cargo IDs or randomized/variational cargo ID lists
~~~~~~~~~

May appear only *after* the sprite block (action 1) it corresponds
to, and not after any other sprite block.

Data is <veh-type> <cargo-id> <num-loadtypes> <num-loadingtypes> <loadtypes...>

	B veh-type	see action 0
	B cargo-id	ID of this particular definition, must be unique
			for each sprite set
	B num-loadtypes	bits 0-6: how many different states of load this set
			can display, while the vehicle is in motion
			bit 7: if set, this is not a cargo ID but a randomized
			or variational cargo ID list (see below)
	B num-loadingtypes
			same as num-loadtypes but shown while vehicle is
			either loading or unloading
	W loadtypes...	sprite ids for each of the states of load; first for the
			"in motion" load states and then the "loading/unloading"
			load states

A cargo ID defines a super-set of sprite sets that go together to display
a certain cargo type, at various states of motion or loading.  For example,
for a certain vehicle, you might have one cargo ID for coal, one for iron
ore and one for grain.  Several cargo IDs can share sprites, for example
the empty sprite might be the same for several cargo types.

Both the num-loadtypes and num-loadingtypes must not be zero, or a division
by zero may occur.

If there is only one load type, it is shown for all loads
If there are two load types, the first is shown below 50%, the other above 50%
If there are three load types, they are shown above/below 33% and 66%
If there are four load types, they are shown above/below 25%, 50% and 75%
etc...

If num-loadtyoes has bit 7 set, the action is interpreted differently,
depending on the value of num-loadtypes.

In that case, it specifies a list of cargo IDs instead, providing an
intermediate step in the sprite determination.  Such a definition can itself
specify randomized or variational cargo IDs, and the chain is followed until
a regular cargo ID (def-type 00) is reached.  Note that the cargo IDs a
randomized or variational definition refers to must have been defined before
that definition, i.e. you can't refer to cargo IDs before they have been
defined.


For num-loadtypes 80:	list of randomized cargo IDs

Data is <veh-type> <cargo-id> <80> <random-type> <nrand> <randbit> <cargo-IDs...>

	B veh-type	same as above
	B cargo-id	same as above, can't share the same number with
			another cargo ID
	B 80		literal 80 (hex) to indicate a randomized cargo ID list
	B random-type	a bitmask of triggers that cause the sprite to change
			01	whenever the vehicle gets a new cargo load
			02	whenever the vehicle enters a depot and is
				serviced
			80	only change if *all* triggers are met,
				by default changes if *any* triggers are met
			(currently no other bits are defined)
	B randbit	number of lowest bit to consider for the random number
			should be zero unless this random definition references
			another randomized cargo ID list
	B nrand		how many different randomized cargo IDs to show
			must be a power of two (e.g. 2, 4, 8, 16....)
	W cargo-IDs	list of nrand different cargo-IDs that are chosen randomly
			you can of course list a cargo-ID multiple times to
			increase its probability

	When displaying vehicles in the purchase list, the game will always
	show the first cargo-ID listed, not a random one.

	If you have several random cargo ID lists in a chain, normally all of
	them would check the same bits in an eight-bit randomized value.  To
	prevent that, choose randbit such that all random checks are linearly
	independent, or at least as independent as possible.  For example,
	if one check has 8 possibilities, it needs three bits (values 0-7).
	If you have another check, this means you shouldn't use the first
	three bits, so set randbit to 3.  Then, if you have another check,
	increase randbit again, but make sure not to check for any bits
	above bit 7, because those bits will always be zero.

	The cargo ID is always randomized when a vehicle is first bought,
	but from then on it only changes when any or all of the trigger
	conditions are met.  These conditions are checked according to
	the current graphics, so if there are several random lists in a
	chain, only the triggers of the chain that defines the current
	graphics matter.  To be on the safe side, always have identical
	triggers in the final random list of a chain.

For num-loadtypes 81:	list of variational but deterministic cargo IDs

Data is <veh-type> <cargo-id> <81> <variable> <shift-num> <AND-mask>
		<nvar> <cid-definitions...> <default-cid>

	Each cid-definition (except for the default-cid) is in the
	form <low-range> <high-range> <cargo-ID>

	B veh-type	same as above
	B cargo-id	same as above, can't share the same number with
			another cargo ID
	B 81		literal 81 (hex) to indicate a variational cargo ID list
	B variable	what variable determines the cargo ID to choose
			00 current date (counted as days from 1920)
			01 current year (count from 1920, max. 2175 even with eternalgame)
			02 current month
			03 current climate
			80+x vehicle property (where x is the offset in veh struct)
			for example,
			B4 current vehicle speed (speed is at 34) [1]
			C0 vehicle age in days (age is at 40)
			C4 year built (counted from 1920)
	B shift-num	is a number of bits that the variable is right-shifted
	B AND-mask	is a bit-mask to AND the value of the variable with
			after shifting it
			use FF to leave all bits as they are
	B nvar		how many different ranges of values there are

	W cargo-ID	cargo-ID to use for this range of values
	B low-range	lower bound of the range of values
	B high-range	upper bound of the range of values

	W default-cid	default cargo ID to use if none of the ranges
			below matches

	When displaying vehicle in the purchase list, the game will show
	those variations based on external variables (dates etc.) correctly,
	but variations based on vehicle properties (speed, age etc.) will
	always show the first (not the default) cargo-ID.

	Since only byte-ranges are supported, you must use the shift-num to
	move the value into a useful range.  For example, the vehicle age
	is normally a two-byte value.  If you want to specify the age range
	15-20 years, the age would be 5479-7305 in days.  To get this to
	fit in a byte value, you have to shift it to the right by 5 bits,
	yielding 171-228, which introduces a slight rounding error of course.

	Then you specify the range 171 (AB) to 228 (E4), for example using this
	pseudo-sprite data (parenthesis for emphasis only):

	* 17	00 03 81 C0 05 FF 02 (00 00 00 AA) (01 00 AB E4) (02 00)

	This will use cargo ID 0 if the age is 0 to 5471 days, ID 1 if the
	age is from 5472 to 7328 days, and ID 2 otherwise.


	[1] Note that the unit of the speed depends on the vehicle type
	    For trains: in mph/1.6
	    For road vehicles and ships: in mph/3.2
	    For planes: in mph
	    Also this is only valid for the first engine, not wagons or
	    additional engines.

Action 3:	Associate cargo IDs with vehicles
~~~~~~~~~

May appear only *after* all corresponding cargo IDs have been
defined by an action 2 entry in this .grf file.

Data is <veh-type> <n-vid> <veh-id>... <num-vcid> [<cargo-type> <cid>]... <def-cid>

	B veh-type	see action 0
	B n-vid		bits 0-6: how many vehicle IDs this definition applies to
			bit 7: if set, this is a wagon override definition (see below)
	B veh-id	the vehicle IDs (counted from the first of its class)
	B num-vcid	number of vehicle-specific cargo IDs in this definition
	B cargo-type	type of this cargo type (e.g. mail=2, wood=7, see below)
	W cid		cargo ID for this type of cargo
	W def-cid	default cargo ID


If n-vid has bit 7 set, this action 3 must immediately follow an action 3.
The engines defined by the first action 3 will then have an override for
wagon sprites.  This means that you can specify here a number of wagons
that will have different graphics when attached to these engines.

These wagons will use the cargo IDs in the second action 3 whenever they are
attached to one of the engine(s) defined in the first action 3.  Additional
action 3 entries may follow, and if they are overrides, they always apply
to the last action 3 that wasn't an override, but they must always follow
one another with no other actions in between.

For example, if the first action 3 defines the graphics for a train engine,
the following action 3 can have bit 7 set in the n-vid byte, and list the
train wagons whose graphics shall be different if attached to that train
engine.

Note that you need to set the wagon's sprite number to FD using action 0,
or it will only show the default sprite.  You do not need to specify any
other cargo IDs for these wagons though, they will happily use the default
sprite if no other definitions exist.


Action 4:	Define new vehicle names.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <veh-type> <language-id> <num-veh> <offset> <data...>

	B veh-type	see action 0
	B language-id	language ID (see below)
	B num-veh	number of vehicles which are getting a new name
	B offset	number of the first vehicle that gets a new name
	S data		new names, each of them zero-terminated, after
			which the next name begins.

Action 4 is only applied if the language-id has a bit set for TTD's
current language.

	Language  Bit  Value
	American  0	01
	English	  1	02
	German	  2	04
	French	  3	08
	Spanish   4	10

Specify a language-id of 1F to apply this action 4 no matter what the
language of TTD is.

The language is determined from the filesize of the TTD executable file.
This means that if TTD Translator has been used to translate this copy,
action 4 will still be applied for the language that the file used to be in,
not the one it has been translated to, of course.


Action 5:	Define new non-vehicle sprite blocks.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <graphics-type> <num-sprites> <other data...>

	B graphics-type	What set of graphics the sprites define.
	B num-sprites	How many sprites are in this set?
	B other data	Graphics type specific data.  Not defined yet.

Possible values for graphics-type:
	4  Pre-signal graphics (48 sprites)
	5  Overhead wires and pylons for electrified railways (xx sprites)


Action 6:	Apply parameter to following pseudo-sprite or sprite.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <param-num> <param-size> <offset> ... <FF>

	B param-num	Number of parameter to substitute (First = "zero")
			Ignored if that parameter was not specified in newgrf.txt
	B param-size	How many bytes to replace.  If larger than 4, the
			bytes of the following parameter are used.  In that
			case, nothing is applied unless *all* parameters
			were specified.
	B offset	Offset into data from beginning of next sprite
			to place where parameter is to be stored

Notes:

The triplet of number, size and offset can be repeated as often
as necessary, for any kind of values.  The final byte must be
a literal "FF" to indicate the end of the list, as TTDPatch cannot
easily determine the length of a pseudo-sprite.

This action is processed only in the initialization of a .grf file and
is ignored during the activation.


Action 7:	Skip next n sprites if condition is true.
~~~~~~~~~

May appear anywhere in the .grf file.

Data is <param-num> <param-size> <condition-type> <value> <num-sprites>

	B param-num	See action 6
			Additionally, the following values test in-game
			variables:
			83 B current climate[2]
			84 B .grf loading stage, 0=initialization, 1=activation
			(all other values greater 80 are reserved)
			Notes:
				[1] Only valid during initialization
				[2] Only valid during activation
	B param-size	See action 6 (ignored for bit tests)
	B condition-type
			What condition to test for:
				0  test for bit value being set
				1  test for bit value being unset
				2  param is equal to value
				3  param is not equal to value
				4  param is greater than value
				5  param is less than value
	V value		Bit number (a byte), or value to compare with
			If a value is not a bit number, it has as many bytes
			as the param-size specifies.
	B num-sprites	How many sprites to skip if the condition is true
			Special value 00 means skip rest of this grf file

Notes:

Take care that the number of sprites to skip does not end in the middle
of a non-pseudo-sprite block, or TTDPatch will attempt to interpret these
regular sprites as pseudo-sprites, and will most likely crash.  Also don't
skip beyond the end of a .grf file.  If you need to skip the rest of a .grf
file, just use num-sprites = 0.


Action 8:	Define GRF ID
~~~~~~~~~

Must be the first pseudo-sprite of a .grf file except for one or more
action 7 entries that may (and probably should) come before it.

Data is <version> <grf-id> <<description> <copyright>

	B version	newgrf version, currently 01
	4*B grf-id	globally unique ID of this .grf file
	S description	description of the contents of this .grf file,
	S copyright	copyright string describing the author and copyright

This action is currently optional, but will be mandatory starting from the
first beta version at the latest.

The version must match or be compatible with the newgrf version of the
intended TTDPatch version, see below.

The grf-id must be a globally unique ID.  To choose an ID, use the initials
of your first and last name as the first two bytes, along with two more bytes
of your own choice as the last two bytes.  For example, if you are
"Foobar Z. Boozle", use 46 42 00 00 for your first file, and 46 42 00 01
for your second one.  If someone else has already used these initials,
please use a different capitalisation or simply two other letters to keep the
IDs unique.  The ID must not be the same as that of any other .grf file,
either yours or somebody else's.  It should however be the same for both
the DOS and Windows versions of a grf file.  If you make an update to a .grf
file and think that it will be backward compatible with the savegames, give
it the same ID as the original file.  To make it necessary to reactivate the
.grf file, use a new ID.

The ID is used to identify the .grf files to activate after loading a
savegame.  When a game is saved, the IDs of all currently active .grf
files will be stored, and when the game is loaded, only those .grf files
with matching IDs will be activated (if they are still available).  For
all other .grf files, this action 8 simply skips the rest of the .grf file,
as if it had been a successful action 7.

A .grf file is considered to be active if its action 8 has been processed
successfully.  This means that you should control activation by placing
an action 7 before the action 8, to skip a .grf file for the wrong
climate, for example.

The description should be a short zero-terminated string that describes
the contents of the .grf file.  It might for example be used by other
programs that allow selecting .grf files for newgrf.txt.

The zero-terminated copyright string has no specified format.  It can
contain anything you want to, but if you want to be recognized as the
author of the .grf file, it should be something like
"Copyright (C) 2003 by Foobar Z. Boozle.  All rights reserved."
Optionally you can follow with your contact info and any other
information you want to include in the .grf file.

*Note, the ID checking and grf (de)activation does not work yet as
of 1.9.1 alpha 31*

Newgrf version table

newgrf	compatible
version	with		TTDPatch version
00	00		1.9.1 alpha 27 and earlier
01	00-01		1.9.1 alpha 28 and above
02-FF	- not defined yet -


4)  General information and hints and tips
------------------------------------------

a) The following cargo types are defined by TTDPatch:

Num1	Bitval	Num2	Type
 00	1	 00	Passengers
 01	2	 01	Coal
 02	4	 02	Mail
 03	8	 03	Oil
 04	10	 04	Livestock
 05	20	 05	Goods
 06	40	 06	Grain/Wheat/Maize
 07	80	 07	Wood
 08	100	 08	Iron Ore
 09	200	 09	Steel
 0A	400	 0A	Valuables/Gold/Diamonds
 0B	800	 09	Paper
 0C	1000	 0B	Food
 0D	2000	 04	Fruit
 0E	4000	 08	Copper Ore
 0F	8000	 09	Water
 10	10000	 01	Rubber
 11	20000	 01	Sugar
 12	40000	 03	Toys
 13	80000	 04	Batteries
 14	100000	 05	Candy (Sweets)
 15	200000	 06	Toffee
 16	400000	 07	Cola
 17	800000	 08	Cotton Candy (Candyfloss)
 18	1000000	 09	Bubbles
 19	2000000  0A	Plastic
 1A	4000000	 0B	Fizzy Drinks
 FF	n/a	 n/a	Shown in purchase list


Num1 is what you use in action 3.
Bitval is (1<<Num1), and it is what you add up to make the bit mask for action 0.
Num2 is what you use as cargo type in action 0.

Note that using a cargo type of FF in action 3 allows you to decide which
cargo ID to show in the purchase list.



b) General strategy for implementing new graphics in the .grf file:

1) First sprite is special, defining the total number of entries in the .grf
   file
2) Start with one or more action 7 entries that decide whether or not to
   load these graphics, for example based on the current climate.
3) After the action 7 entries, define your GRF ID with action 8.
4) Then define one or several action 0 entries, that (possibly among other
   things) set the vehicle sprite IDs to FD (trains) or FF (all other vehicle
   types).  Only vehicles with the sprite IDs will be using the new sprites.
5) Start a block of new graphics with an action 1 (sprite block) entry,
   followed by the actual sprite data.  Ideally, you put the graphics of all
   vehicles together in this one sprite block, taking note of what sets of
   sprites have what number (as determined by their position in the block).
6) After action 1, give action 2 (cargo ID) entries for each different
   combination of vehicle and cargo type.  The cargo IDs should start at zero
   and be numbered consecutively.
7) After all action 2 entries, use action 3 (veh ID to cargo ID maps) to
   specify what cargo IDs are to be shown for which vehicle and which cargo
   types.

Note that there may be *no* action 1 between the final action 3 for that
sprite block.  The order must always be

	Action 1
	(Sprite block)
	Action 2 (possibly several)
	Action 3 (possibly several)

After that, you can have a new action 1 and another sprite block, with its
own action 2 and action 3 entries in the above order.



c) Dealing with the sprite numbers and pseudo-sprite blocks

It can be quite a chore to make sure that the sprite numbers increase
by one, and that you have the correct length for the pseudo-sprite blocks.
Currently, GRFCodec has only limited parsing capabilities, so you need to
make sure that they are indeed correct.

One help in this task is a Perl script called renum.pl, which you can find
in this directory.  If you haven't heard of Perl before, it's a powerful
programming language that you can get for free.  For example, you can
install it with the Cygwin packages (www.cygwin.com), or from activestate.com
and perl.com.

If you have written a .nfo file, but it doesn't have the right numbers for
the sprites or the lengths, run the renum.pl script like this:

perl renum.pl < your.nfo > yournew.nfo

It will take the your.nfo (substitute your actual filename), and write
yournew.nfo with correct sprite numbers and pseudo-sprite lengths.

Note that the format of the .nfo needs to be correct for this to work
properly; in particular, the sprite numbers and pseudo-sprite lengths must
already be *there* (as dummy numbers), but they need not be correct.



d) How to only load your graphics in some circumstances

For example, you only want your graphics to be active in the right climate,
or only if some other condition is true.

For this, the first entries in your .grf file must be actions 7 which test
that condition, and skip the rest of the file if true.  To skip the rest
of the file, remember to specify a <num-sprites> parameter of 00.

Immediately *after* your initial action 7 entries, you place the action 8
that defines your GRF ID.

This way, the .grf file is considered active or inactive in the right
circumstances.



e) The two stages of loading a .grf file

Every .grf file is processed in two stages.  The first stage, initialization,
is run only once.  In this stage, TTDPatch records the GRF IDs, and resolves
all cargo IDs and sprite IDs.

During initialization, actions 0, 3, 4, 5 and 7 are ignored.  Action 6 is
carried out *only* during initialization.  Action 7 is ignored because
otherwise the sprite IDs and cargo IDs that are skipped won't be resolved.
Action 8 has the GRF ID recorded so that it can be looked up later.

A .grf file is activated only if it was active when the game was started.  If
a game is loaded, only its active .grfs will be reactivated, unless
"loadallgraphics on" is used.  A .grf file is considered active if its
action 8 has been processed, i.e. its action 8 hasn't been skipped using
an action 7.

During activation, only actions 0, 3, 4, 5, 7 and 8 are carried out.  All
others are ignored, because they only need to be processed once at
initialization.



f) Final words

Now, after reading all this, go back to section 1, and see if you can
understand how that pseudo-sprite works.  Then all should be clear!
