Cargo types:
num	bitval	type
 0	1	Passengers
 1	2	Coal
 2	4	Mail
 3	8	Oil
 4	10	Livestock
 5	20	Goods
 6	40	Grain/Wheat/Maize
 7	80	Wood
 8	100	Iron Ore
 9	200	Steel
10	400	Valuables/Gold/Diamonds
11	800	Paper
12	1000	Food
13	2000	Fruit
14	4000	Copper Ore
15	8000	Water
16	10000	Rubber
17	20000	Sugar
18	40000	Toys
19	80000	Batteries
20	100000	Candy (Sweets)
21	200000	Toffee
22	400000	Cola
23	800000	Cotton Candy (Candyfloss)
24	1000000	Bubbles
25	2000000 Plastic
26	4000000	Fizzy Drinks
255	n/a	Shown in purchase list (no actual cargo ID available)



Format of new ttdpatch.grf pseudo-sprite instructions:
Each instruction looks like this in the .NFO file:

*   <length>  <action> <data>

length is specified in decimal, command is one hex byte and
data are a series of <length> bytes in hex

action specifies what to do with the following data

  Action	What it does
	0	Change vehicle info (like TTD Alter)
	1	Define new sprite block
	2	Define new cargo ID: mapping of cargo type and load status to sprite
	3	Define vehicle to cargo ID mapping
	4	Define new vehicle names
	5	New graphics such as pre-signals and overhead wires
	6	Apply newgrf.txt parameter to following sprite data
	7	Skip following sprites if condition is true


Specifics of the data for these actions:

Note, the descriptions of the parameters are organized in this manner:
	Size  Name  Description

The size can be B for a single byte, W for a two-byte word,
D for a four-byte dword, S for a zero-terminated string, or
V for a variable size.  Words and dwords are in little-endian
byte order.  If variable size is specified, the actual size depends
on other parameters and is explained in the description.


First sprite:

	The first sprite in each .grf file has a special format.

*   4  <num-entries>

	D num-entries	The total number of sprites and pseudo-sprite
			in this .grf file.  May be slightly larger than
			the actual number, but must not be smaller.
			Given as four bytes in little-endian format.


Action 0:	Define new vehicle properties.

	May appear anywhere in the .grf file.

	Data is <veh-type> <num-props> <num-info> <offset>
		then repeated numprops times: <property> <new-info>

	B veh-type	0..3 to replace trains, road vehicles, ships or planes
			(currently only ships work)
	B num-props	how many properties to change
	B num-info	how many vehicles to change
	B offset	offset into each property (i.e. how many vehicles
			to skip before the first one to change)
	B property	what property to change, depends on the veh. type
	V new-info	new bytes of info (variable size)

	Properties common to all vehicle types
	number	size	property
	0	W	date of introduction (will have random amount added)
	4	B	engine life in years
	6	B	climates available (bit mask)

	all of the above only apply to new games, or when using Cht: ReloadEngines

	Note, engine life also determines how long this engine can be bought
	after being introduced (without using persisentengines).


	Properties for trains
	-none at the moment-

	Properties for road vehicles
	-none at the moment-

	Properties for aircraft
	-none at the moment-

	Properties for ships
	number	size	property
     8	B	sprites
	9	B	refittable (0 no, 1 yes)
	10	B	cost base
	11	B	speed in mph*3.2
	12	B	default cargo type
	13	W	capacity
	15	B	base maintenance cost
	16	D	bit mask of cargo types available for refitting


Action 1:	Define new vehicle sprite blocks.

	May appear anywhere in the .grf file.

	Data is <veh-type> <num-sprites> <num-dirs>

	B veh-type	same as action 0 (currently only ships work)
	B num-sprites	number of set of num-dirs sprites

The following num-sprites * num-dirs sprites will be actual sprites,
not pseudo-sprites


Action 2:	Define cargo IDs.

	May appear only *after* the sprite block (action 1) it corresponds
	to, and not after any other sprite block.

	Data is <veh-type> <cargo-id> <display-type> <data...> <num-loadtypes> <num-loadingtypes> <loadtypes...>

	B veh-type	same as action 0 (currently only ships work)
	B cargo-id	ID of this particular cargo (w.r.t. what sprites to show)
			Cargo IDs must be unique for each sprite block defined
			by action 1, and are forgotten when the next action 1
			is encountered.
	B num-loadtypes	how many different states of load this set can display
			this must not be zero, or division by zero will occur
			these are only the number of loadtypes while in motion
	B num-loadingtypes
			same as num-loadtypes but shown while ship is loading/unloading
	B loadtypes...	sprite ids for each of the states of load; first for the
			"in motion" load states and then the "loading/unloading"
			load states

Note
If there is only one load type, it is shown for all loads
If there are two load types, the first is shown below 50%, the other above 50%
If there are three load types, they are shown above/below 33% and 66%
If there are four load types, they are shown above/below 25%, 50% and 75%
etc...


Action 3:	Associate cargo IDs with vehicles.

	May appear only *after* all corresponding cargo IDs have been
	defined by an action 2 entry.

	Data is <veh-type> <n-vid> <veh-id>... <num-vcid> [<cargo-num> <cid>]... <def-cid>

	B veh-type	same as action 0 (currently only ships work)
	B n-vid		how many vehicle IDs this definition applies to
	B veh-id	the vehicle IDs (counted from the first of its class)
	B num-vcid	number of vehicle-specific cargo IDs in this definition
	B cargo-type	number of this cargo type (e.g. mail=2, wood=7)
	W cid		cargo ID for this type of cargo
	W def-cid	is the default cargo ID, if the actual cargo type
			doesn't match any of the previous cargos
NOTE 1: Location of def-cid changed from before TTDPatch 1.9.1 alpha 5!
NOTE 2: Cargo IDs are now WORD values here (I need two bytes)!


Note
New sprites are used if the sprite number stored in the vehicle structure
is equal to FF
Then the vehicle's veh-id is looked up, and searched for its cargo
The cargo-id that is found is then used to determine the load status,
and the base sprite id to use
Finally, the current direction is added to the base sprite id, and returned


Action 4:	Define new vehicle names.

	May appear anywhere in the .grf file.

	Data is <veh-type> <num-veh> <offset> <data...>

	B veh-type	same as action 0 (currently only ships work)
	B num-veh	number of vehicles which are getting a new name
	B offset	number of the first vehicle that gets a new name
	S data		new names, each of them zero-terminated, after
			which the next name begins.


Action 5:	Define new non-vehicle sprite blocks.

	May appear anywhere in the .grf file.

	Data is <graphics-type> <num-sprites> <other data...>

	B graphics-type	Can have any of the following values:
				4  Pre-signal graphics
				5  Overhead wires and pylons for electrified railways
	B num-sprites	How many sprites are in this set?
	B other data	Graphics type specific data.  Not defined yet.


Action 6:	Apply parameter to following pseudo-sprite or sprite.

	May appear anywhere in the .grf file.

	Data is <param-num> <param-size> <offset> ... <00>

	B param-num	Number of parameter to substitute (First = "zero")
			Ignored if that parameter was not specified in newgrf.txt
	B param-size	How many bytes to replace.  If larger than 4, the
			bytes of the following parameter are used.  In that
			case, nothing is applied unless *all* parameters
			were specified.
	B offset	Offset into data from beginning of next sprite
			to place where parameter is to be stored

	The triplet of number, size and offset can be repeated as often
	as necessary, for any kind of values.  The final byte must be
	a literal "00" to indicate the end of the list.


Action 7:	Skip next n sprites if condition is true.

	May appear anywhere in the .grf file.

	Data is <param-num> <param-size> <condition-type> <value> <num-sprites>

	B param-num	See action 6
	B param-size	See action 6
	B condition-type
			What condition to test for:
				0  test for bit value being set
				1  test for bit value being unset
				2  param is equal to value
				3  param is not equal to value
				4  param is greater than value
				5  param is less than value
	V value		Bit number (a byte), or value to compare with
			If a value not a bit number, it has as many bytes
			as the param-size specifies.
	B num-sprites	How many sprites to skip if the condition is true



General strategy for implementing new graphics in the .grf file:
* Don't forget that the first sprite is special
* Action 0 (new properties) can appear anywhere in the .grf file,
	or nowhere if the sprite numbers are set to FF somewhere else.
* Start a block of new graphics with an action 1 (sprite block) entry,
	followed by the actual sprite data.
* After action 1, give action 2 (cargo ID) entries for each different
	vehicle and cargo type combination
* After all actions 2, use action 3 (veh ID to cargo ID maps) to specify
	what cargo IDs are to be shown for which vehicle and which cargo types
* There may be *no* action 1 between the final action 3 for that sprite
	block

Remember that:
- cargo types are what the vehicle will actually transport, e.g. passengers,
	coal, iron ore etc.
- cargo IDs are numbers unique to each sprite block, one for each different
	cargo type that each new vehicle can transport

